<script>
// ============================================
// SOUND SYSTEM (8-bit beeps)
// ============================================
// Audio subsystem namespace to avoid global clutter
let soundEnabled = false;
const GameAudio = (() => {
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;

  async function initAudio() {
    if (!audioCtx && AudioCtx) {
      try {
        audioCtx = new AudioCtx();
        // Resume context if it was created in suspended state (browser policy)
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
      } catch (e) {
        console.warn('[GameAudio] Failed to initialize audio:', e);
        audioCtx = null;
      }
    } else if (audioCtx && audioCtx.state === 'suspended') {
      // Resume if context exists but is suspended
      try {
        await audioCtx.resume();
      } catch (e) {
        console.warn('[GameAudio] Failed to resume audio:', e);
      }
    }
  }

  function playBeep(freq = 440, duration = 0.1, type = 'square') {
    if (!soundEnabled || !audioCtx || audioCtx.state !== 'running') return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    } catch (e) {
      // Silently fail - audio is non-critical
    }
  }

  function playKeyPress() { playBeep(800, 0.02); }
  function playEnter() { playBeep(600, 0.05); }
  function playError() { playBeep(200, 0.15, 'sawtooth'); }
  function playSuccess() {
    playBeep(523, 0.1);
    setTimeout(() => playBeep(659, 0.1), 100);
    setTimeout(() => playBeep(784, 0.15), 200);
  }
  function playAlert() { playBeep(440, 0.1); setTimeout(() => playBeep(440, 0.1), 150); }
  function playBoot() {
    [200, 300, 400, 500, 600].forEach((f, i) => {
      setTimeout(() => playBeep(f, 0.08), i * 60);
    });
  }

  async function toggleSound() {
    soundEnabled = !soundEnabled;
    if (soundEnabled) {
      await initAudio();
    }
    return soundEnabled;
  }

  return {
    initAudio,
    playBeep,
    playKeyPress,
    playEnter,
    playError,
    playSuccess,
    playAlert,
    playBoot,
    toggleSound,
    get enabled() { return soundEnabled; }
  };
})();

// Backwards-compatible globals used elsewhere in the game
const initAudio = GameAudio.initAudio;
const playBeep = GameAudio.playBeep;
const playKeyPress = GameAudio.playKeyPress;
const playEnter = GameAudio.playEnter;
const playError = GameAudio.playError;
const playSuccess = GameAudio.playSuccess;
const playAlert = GameAudio.playAlert;
const playBoot = GameAudio.playBoot;

// ============================================
// i3 BAR SYSTEM
// ============================================
function updateI3Bar() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
  const dateStr = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
  document.getElementById('i3-time').textContent = `${dateStr} ${timeStr}`;

  if (Math.random() < 0.1) {
    const cpu = Math.floor(Math.random() * 30) + 5;
    const mem = (Math.random() * 2 + 1.5).toFixed(1);
    document.getElementById('i3-cpu').textContent = `cpu: ${cpu}%`;
    document.getElementById('i3-mem').textContent = `mem: ${mem}G`;
  }
}

// Pause updates when tab is hidden to save resources
let i3BarInterval = null;

function startI3Bar() {
  if (i3BarInterval) return;
  i3BarInterval = setInterval(updateI3Bar, 1000);
  updateI3Bar();
}

function stopI3Bar() {
  if (i3BarInterval) {
    clearInterval(i3BarInterval);
    i3BarInterval = null;
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopI3Bar();
  } else {
    startI3Bar();
  }
});

startI3Bar();

function setI3Mode(mode) {
  document.getElementById('i3-mode').textContent = mode ? `[${mode}]` : '';
}

function setActiveWorkspace(ws) {
  document.querySelectorAll('.i3-workspace').forEach(el => {
    el.classList.toggle('active', el.dataset.ws === String(ws));
  });
}

// ============================================
// CODE EDITOR SYSTEM (vim-like)
// ============================================
const codeEditor = {
  isOpen: false,
  mode: 'normal',
  filename: 'exploit.c',
  content: '',
  savedContent: '',
  onSave: null,
  cursorLine: 1,
  cursorCol: 1,
  // Visual mode state (vim-like)
  visualMode: 'none', // 'none' | 'char' | 'line'
  visualAnchor: 0
};

function openCodeEditor(filename, content, onSave) {
  codeEditor.filename = filename;
  codeEditor.content = content;
  codeEditor.savedContent = content;
  codeEditor.onSave = onSave;
  codeEditor.isOpen = true;

  document.getElementById('code-editor-overlay').style.display = 'flex';
  document.getElementById('code-editor-filename').textContent = filename;
  document.getElementById('code-editor-content').value = content;

  updateEditorLineNumbers();
  setActiveWorkspace(3);
  setEditorMode('normal');
  document.getElementById('code-editor-content').focus();

  // Brief inline help for non-vim users
  print('[editor] i = insert, :w = save, :q = quit, :wq = save & quit', 'info');
  updateEditorStatus();
}

function closeCodeEditor(save = false) {
  if (save && codeEditor.onSave) {
    codeEditor.onSave(document.getElementById('code-editor-content').value);
  }
  codeEditor.isOpen = false;
  document.getElementById('code-editor-overlay').style.display = 'none';
  setActiveWorkspace(1);
  document.getElementById('terminal-input').focus();
}

function updateEditorLineNumbers() {
  const content = document.getElementById('code-editor-content').value;
  const lines = content.split('\n').length;
  let lineNums = '';
  for (let i = 1; i <= Math.max(lines, 20); i++) {
    lineNums += i + '\n';
  }
  document.getElementById('code-editor-lines').textContent = lineNums;
}

function setEditorMode(mode) {
  codeEditor.mode = mode;
  const textarea = document.getElementById('code-editor-content');
  const modeDisplay = document.getElementById('code-editor-mode');
  const cmdLine = document.getElementById('code-editor-command');

  // Leaving any visual mode when changing primary mode
  codeEditor.visualMode = 'none';

  switch (mode) {
    case 'normal':
      modeDisplay.textContent = '-- NORMAL --';
      // Keep textarea editable so the browser caret blinks,
      // but we'll intercept keys in normal mode to prevent text changes.
      textarea.readOnly = false;
      cmdLine.style.display = 'none';
      break;
    case 'insert':
      modeDisplay.textContent = '-- INSERT --';
      textarea.readOnly = false;
      cmdLine.style.display = 'none';
      break;
    case 'command':
      modeDisplay.textContent = '';
      cmdLine.style.display = 'block';
      document.getElementById('code-editor-cmd-input').value = ':';
      document.getElementById('code-editor-cmd-input').focus();
      break;
  }
}

function getEditorCursorPosition() {
  const textarea = document.getElementById('code-editor-content');
  const pos = textarea.selectionStart;
  const before = textarea.value.slice(0, pos).split('\n');
  const line = before.length;
  const col = before[before.length - 1].length + 1;
  return { pos, line, col };
}

function updateEditorStatus() {
  const { line, col } = getEditorCursorPosition();
  document.getElementById('code-editor-status').textContent = `Ln ${line}, Col ${col}`;
}

function updateVisualSelection() {
  const textarea = document.getElementById('code-editor-content');
  if (codeEditor.visualMode === 'none') return;

  const currentPos = textarea.selectionStart;
  const anchor = codeEditor.visualAnchor;
  const value = textarea.value;

  if (codeEditor.visualMode === 'char') {
    const start = Math.min(anchor, currentPos);
    const end = Math.max(anchor, currentPos);
    textarea.setSelectionRange(start, end);
  } else if (codeEditor.visualMode === 'line') {
    const lineStartFrom = value.lastIndexOf('\n', anchor - 1) + 1;
    const lineStartTo = value.lastIndexOf('\n', currentPos - 1) + 1;
    const lineEndFrom = value.indexOf('\n', anchor);
    const lineEndTo = value.indexOf('\n', currentPos);
    const start = Math.min(
      lineStartFrom,
      lineStartTo === -1 ? 0 : lineStartTo
    );
    const end = Math.max(
      lineEndFrom === -1 ? value.length : lineEndFrom,
      lineEndTo === -1 ? value.length : lineEndTo
    );
    textarea.setSelectionRange(start, end);
  }

  updateEditorStatus();
}

function handleEditorCommand(cmd) {
  cmd = cmd.trim();
  if (cmd === ':w') {
    if (codeEditor.onSave) {
      codeEditor.onSave(document.getElementById('code-editor-content').value);
      codeEditor.savedContent = document.getElementById('code-editor-content').value;
    }
    setEditorMode('normal');
    print(`"${codeEditor.filename}" written`, 'system');
  } else if (cmd === ':q') {
    closeCodeEditor(false);
  } else if (cmd === ':wq' || cmd === ':x') {
    closeCodeEditor(true);
  } else if (cmd === ':q!') {
    document.getElementById('code-editor-content').value = codeEditor.savedContent;
    closeCodeEditor(false);
  } else {
    setEditorMode('normal');
  }
}

document.addEventListener('keydown', (e) => {
  if (!codeEditor.isOpen) return;
  const textarea = document.getElementById('code-editor-content');

  if (codeEditor.mode === 'normal') {
    // Always keep focus in the editor while it's open
    if (document.activeElement !== textarea) {
      textarea.focus();
    }

    // Vim-like commands
    if (e.key === 'i') {
      e.preventDefault();
      setEditorMode('insert');
      return;
    } else if (e.key === ':') {
      e.preventDefault();
      setEditorMode('command');
      return;
    } else if (e.key === 'v' && !e.ctrlKey && !e.metaKey && !e.altKey) {
      // Toggle visual (character-wise) mode
      e.preventDefault();
      if (codeEditor.visualMode === 'char') {
        codeEditor.visualMode = 'none';
        // Collapse selection to cursor
        const pos = textarea.selectionStart;
        textarea.setSelectionRange(pos, pos);
      } else {
        codeEditor.visualMode = 'char';
        codeEditor.visualAnchor = textarea.selectionStart;
      }
      updateVisualSelection();
      return;
    } else if (e.key === 'V' && !e.ctrlKey && !e.metaKey && !e.altKey) {
      // Toggle visual line mode
      e.preventDefault();
      const value = textarea.value;
      const pos = textarea.selectionStart;
      if (codeEditor.visualMode === 'line') {
        codeEditor.visualMode = 'none';
        const collapsePos = pos;
        textarea.setSelectionRange(collapsePos, collapsePos);
      } else {
        codeEditor.visualMode = 'line';
        codeEditor.visualAnchor = pos;
      }
      updateVisualSelection();
      return;
    } else if (e.key === 'Escape') {
      codeEditor.visualMode = 'none';
      setEditorMode('normal');
      // Collapse any selection
      const pos = textarea.selectionStart;
      textarea.setSelectionRange(pos, pos);
      updateEditorStatus();
      return;
    }

    // hjkl navigation (left/down/up/right)
    const navTextarea = textarea;
    const value = navTextarea.value;
    const pos = navTextarea.selectionStart;

    const moveCursor = (offsetFunc) => {
      const newPos = offsetFunc(pos, value);
      navTextarea.setSelectionRange(newPos, newPos);
      updateVisualSelection();
      updateEditorStatus();
    };

    if (e.key === 'h') {
      e.preventDefault();
      moveCursor((p) => Math.max(0, p - 1));
      return;
    }

    if (e.key === 'l') {
      e.preventDefault();
      moveCursor((p, v) => Math.min(v.length, p + 1));
      return;
    }

    if (e.key === 'k' || e.key === 'j') {
      e.preventDefault();
      // Compute current line/col
      const before = value.slice(0, pos);
      const lines = before.split('\n');
      const currentLine = lines.length - 1; // 0-based
      const col = lines[lines.length - 1].length;
      const allLines = value.split('\n');

      let targetLine = currentLine + (e.key === 'j' ? 1 : -1);
      if (targetLine < 0 || targetLine >= allLines.length) {
        // Stay on same line if moving out of bounds
        targetLine = currentLine;
      }

      // Calculate new absolute position
      let newPos = 0;
      for (let i = 0; i < targetLine; i++) {
        newPos += allLines[i].length + 1; // +1 for '\n'
      }
      newPos += Math.min(col, allLines[targetLine].length);

      navTextarea.setSelectionRange(newPos, newPos);
      updateVisualSelection();
      updateEditorStatus();
      return;
    }

    // 0 -> start of line, $ -> end of line
    if (e.key === '0' || e.key === '$') {
      e.preventDefault();
      const before = value.slice(0, pos);
      const lineStart = before.lastIndexOf('\n') + 1;
      const lineEnd = value.indexOf('\n', pos) === -1 ? value.length : value.indexOf('\n', pos);
      const newPos = e.key === '0' ? lineStart : lineEnd;
      navTextarea.setSelectionRange(newPos, newPos);
      updateVisualSelection();
      updateEditorStatus();
      return;
    }

    // Prevent text modifications in normal mode (keep it navigation-only)
    const editingKeys = [
      'Backspace',
      'Delete',
      'Enter',
      'Tab'
    ];
    const isCharKey =
      e.key.length === 1 &&
      !e.ctrlKey &&
      !e.metaKey &&
      !e.altKey;

    if (editingKeys.includes(e.key) || isCharKey) {
      e.preventDefault();
      return;
    }

    // Let navigation keys move the caret, then update status/visual selection
    const navKeys = [
      'ArrowLeft',
      'ArrowRight',
      'ArrowUp',
      'ArrowDown',
      'Home',
      'End',
      'PageUp',
      'PageDown'
    ];
    if (navKeys.includes(e.key)) {
      setTimeout(() => {
        updateVisualSelection();
        updateEditorStatus();
      }, 0);
    }
  } else if (codeEditor.mode === 'insert') {
    if (e.key === 'Escape') {
      e.preventDefault();
      setEditorMode('normal');
    }
    setTimeout(() => {
      updateEditorLineNumbers();
      updateEditorStatus();
    }, 0);
  } else if (codeEditor.mode === 'command') {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleEditorCommand(document.getElementById('code-editor-cmd-input').value);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      setEditorMode('normal');
    }
  }
});

document.getElementById('code-editor-content')?.addEventListener('click', function() {
  updateEditorStatus();
});

// ============================================
// GAME STATE
// ============================================
const gameState = {
  currentLevel: 0,
  levelsCompleted: [],
  inLevel: false,
  levelState: {},
  commandHistory: [],
  historyIndex: -1,
  hackerName: '',
  attempts: 0,
  needsName: true,
  score: 0,
  easterEggsFound: [],
  // Pivoting state for multi-host levels
  currentHost: 'localhost',
  pivotChain: [],
  networkSegment: 'external'
};

function loadGame() {
  const saved = localStorage.getItem('hackerGame');
  if (!saved) return;

  try {
    const data = JSON.parse(saved);
    if (!data || typeof data !== 'object') throw new Error('Invalid save shape');

    gameState.levelsCompleted = data.levelsCompleted || [];
    gameState.hackerName = data.hackerName || '';
    gameState.needsName = !gameState.hackerName;
    gameState.score = data.score || 0;
    gameState.easterEggsFound = data.easterEggsFound || [];
    gameState.attempts = data.attempts || 0;
    gameState.currentLevel = data.currentLevel || 0;
    gameState.levelState = data.levelState || {};
  } catch (e) {
    console.warn('[hackerGame] Invalid save data, resetting', e);
    localStorage.removeItem('hackerGame');
  }
}

function saveGame() {
  const data = {
    levelsCompleted: gameState.levelsCompleted,
    hackerName: gameState.hackerName,
    score: gameState.score,
    easterEggsFound: gameState.easterEggsFound,
    attempts: gameState.attempts,
    currentLevel: gameState.currentLevel,
    levelState: gameState.levelState
  };
  try {
    localStorage.setItem('hackerGame', JSON.stringify(data));
  } catch (e) {
    console.warn('[hackerGame] Failed to save game:', e);
  }
}

function resetGame() {
  // Reset all game state to defaults
  gameState.currentLevel = 0;
  gameState.levelsCompleted = [];
  gameState.inLevel = false;
  gameState.levelState = {};
  gameState.commandHistory = [];
  gameState.historyIndex = -1;
  gameState.hackerName = '';
  gameState.attempts = 0;
  gameState.needsName = true;
  gameState.score = 0;
  gameState.easterEggsFound = [];
  gameState.currentHost = 'localhost';
  gameState.pivotChain = [];
  gameState.networkSegment = 'external';

  // Clear localStorage
  try {
    localStorage.removeItem('hackerGame');
  } catch (e) {
    console.warn('[hackerGame] Failed to clear save data:', e);
  }

  return true;
}

function autosave() {
  saveGame();
}

function calculateScore() {
  let score = 0;
  score += gameState.levelsCompleted.length * 1000;
  score += gameState.easterEggsFound.length * 500;
  const efficiency = Math.max(0, 500 - (gameState.attempts * 5));
  score += efficiency;
  gameState.score = score;
  return score;
}

function addEasterEgg(id, message) {
  if (!gameState.easterEggsFound.includes(id)) {
    gameState.easterEggsFound.push(id);
    print('');
    print('* EASTER EGG FOUND! *', 'warning');
    print(message, 'success');
    print('+500 points!', 'info');
    print('');
    playSuccess();
    calculateScore();
    autosave();
  }
  return true;
}

// Lightweight namespace for game state helpers
const GameState = {
  state: gameState,
  loadGame,
  saveGame,
  autosave,
  calculateScore,
  addEasterEgg,
  resetGame
};

// ============================================
// TERMINAL OUTPUT
// ============================================
const output = document.getElementById('terminal-output');
const input = document.getElementById('terminal-input');
const prompt = document.getElementById('prompt');
const autocomplete = document.getElementById('autocomplete');
const levelSelect = document.getElementById('level-select');
const hud = document.getElementById('hud');

const MAX_TERMINAL_LINES = 500;

function print(text, className = '') {
  const line = document.createElement('div');
  line.className = 'output-line ' + className;
  line.textContent = text;
  output.appendChild(line);

  // Prevent memory leak by limiting terminal history
  while (output.children.length > MAX_TERMINAL_LINES) {
    output.removeChild(output.firstChild);
  }

  output.scrollTop = output.scrollHeight;
}

function printHTML(html, className = '') {
  const line = document.createElement('div');
  line.className = 'output-line ' + className;
  line.innerHTML = html;
  output.appendChild(line);
  output.scrollTop = output.scrollHeight;
}

function clear() {
  output.innerHTML = '';
}

async function typeText(text, speed = 30, className = '') {
  const line = document.createElement('div');
  line.className = 'output-line ' + className;
  output.appendChild(line);

  for (let i = 0; i < text.length; i++) {
    line.textContent += text[i];
    output.scrollTop = output.scrollHeight;
    if (soundEnabled) playKeyPress();
    await sleep(speed);
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function simulateLoading(text, duration = 2000) {
  const spinner = ['|', '/', '-', '\\'];
  const line = document.createElement('div');
  line.className = 'output-line system';
  output.appendChild(line);

  const start = Date.now();
  let i = 0;
  while (Date.now() - start < duration) {
    line.textContent = `[${spinner[i % spinner.length]}] ${text}...`;
    output.scrollTop = output.scrollHeight;
    i++;
    await sleep(80);
  }
  line.textContent = `[OK] ${text}... done`;
  line.className = 'output-line success';
}

// ============================================
// NETWORK MAP DISPLAY
// ============================================
function printNetworkMap(hosts, currentHost = null) {
  print('');
  print('┌─────────────────────────────────────────────────────────────────┐', 'info');
  print('│                        NETWORK MAP                              │', 'info');
  print('├─────────────────────────────────────────────────────────────────┤', 'info');

  hosts.forEach(host => {
    const isCurrent = host.ip === currentHost;
    const status = host.compromised ? '[PWNED]' : (host.accessible ? '[ACCESS]' : '[LOCKED]');
    const statusColor = host.compromised ? 'success' : (host.accessible ? 'warning' : 'error');
    const marker = isCurrent ? '>>>' : '   ';
    print(`│ ${marker} ${host.ip.padEnd(15)} ${host.name.padEnd(20)} ${status.padEnd(10)} │`, statusColor);
  });

  print('└─────────────────────────────────────────────────────────────────┘', 'info');
  print('');
}

// ============================================
// HUD UPDATES
// ============================================
function updateHUD(level, target, objective, progress = 0) {
  hud.style.display = 'flex';
  document.getElementById('hud-level').textContent = level;
  document.getElementById('hud-target').textContent = target;
  document.getElementById('hud-objective').textContent = objective;
  document.getElementById('hud-progress').textContent = progress + '%';
}

function hideHUD() {
  hud.style.display = 'none';
}

// ============================================
// PROMPT MANAGEMENT
// ============================================
function setPrompt(user, host, path = '~') {
  const symbol = user === 'root' ? '#' : '$';
  prompt.textContent = `${user}@${host}:${path}${symbol}`;
}

function resetPrompt() {
  prompt.textContent = '$';
}
</script>
